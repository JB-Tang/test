# 学习手册
## 2022-01-21
1. 使用css实现毛玻璃效果
    * 使用css中的滤镜属性filter:blur(20px)
2. em,rem,vh,vw
    * em和rem
        * 相似点：都是取决于字体的大小设置，一个单位=字体设置大小
        * 不同点：em取决于使用它的元素的字体的大小；rem取决于html元素的字体大小。
    * vh和vw
        * 视口单位：
            * 浏览器中window.innerWidth和window.innerHeight
            * 移动端：Layout Viewport(布局视口)
        * vw：1vw等于视口宽度的1%
        * vh：1vh等于视口高度的1%
        * vmin：选取vw和vh中最小的那个
        * vmax：选取vw和vh中最大的那个
3. css中position的参数
    * static：默认值
    * ralative：相对于本身
    * absolute：相对于非static的父元素
    * fixed：相对于视口
    * sticky：
        * 在文档中正常显示，但是当随页面滚动到顶部设置的高度时，吸顶
        * 该元素并不脱离文档流，仍然保留元素原本在文档流中的位置
        * 元素固定的相对偏移是相对于离它最近的具有滚动框的祖先元素，如果祖先元素都不可以滚动，那么相对于视口计算元素的偏移量
    * initial：默认值
    * inherit：继承父元素
    * unset：恢复默认（默认值或者继承自父元素）
4. null和undefined
    * 相似点：
        * 将其赋值给变量的表示含义基本相同
        * 都会自动转化为false,相等运算符报告两者相等，即null==undefined
    * 不同点：
        * null表示“无”的对象，undefined表示“无”的原始值
        * null转为数值的时候是0，undefined转为数值时是NaN
        * null表示没有对象，即此处不应该有对象
            * 作为函数的参数，表示该函数的参数不是对象
            * 作为对象原型链的终点
        * undefined表示缺少值，即此处应该有个值，但是还没有定义
            * 变量被声明了，但没有赋值时，就等于undefined
            * 调用函数时，应该提供的参数没有提供，该参数等于undefined
            * 对象没有赋值的属性，该属性的值为undefined
            * 函数没有返回值时，默认返回undefined
        * 使用typeof,null->"object";undefined->"undefined"
## 2022-01-24
1. 数据存储类型的堆和栈
    * 基本数据类型存储在栈中；引用数据类型存储在堆中
    * 实际：
        * 字符串：存储在堆中，将堆中的内存地址存进栈；每次出现新的字符串时，堆中生成新的字符串地址
        * 数值：小整数存储在栈中；其他数字存储方式类似字符串
        * 其他基本数据类型在初始化的时候就在堆中存储了，之后的使用都是直接使用堆中的地址。
2. cookie,session,webStorage(sessionStorage,localStorage)
    * cookie:客户端，大小4KB，不安全
    * session:服务端，过多时会对服务器产生压力
    * webStorage:h5中新增的客户端缓存
        * sessionStorage:临时缓存，只存在一次会话中，关闭浏览器就没有了
        * localStorage:永久缓存，存储在硬盘中，关闭浏览器，下次进入还存在
3. http和https
    * http:默认使用80端口；没有加密；3次握手，速度更快
    * https:默认端口443；使用SSL/TLS加密，更安全；除了3次握手外，还需要9个包，速度稍微慢些；使用的证书免费的少，需要收费
4. flex布局中项目中的flex属性完整表示
    * flex-grow：项目的放大比例，默认是0，即如果存在剩余空间，也不放大。
    * flex-shrink：项目的缩小比例，默认是1，即如果空间不足，该项目将缩小。设置为0,表示空间不足时不缩小。
    * flex-basis：在分配多余空间之前，项目占据的主轴空间。默认值是auto，即项目本来的大小。也可以设置成和width,height属性一样的值（300px）,那么项目将在分配剩余空间之前占据固定300px的空间。
5. 伪元素before与after
    * 创建一个虚假的元素，插入到目标元素内容之前或之后,属于目标元素的子元素
    * 使用.class::before{}；.class::after{}
    * 伪元素必须设置“content”属性，否则伪元素无用
    * 伪元素设置宽高要显示的话，需要加display:block
## 2022-01-25
1. 事件捕获与冒泡
    * 事件阶段：捕获阶段->目标阶段->冒泡阶段
        * 捕获阶段：从文档的根节点流向目标对象
        * 目标阶段：在目标对象上被触发
        * 冒泡阶段：从目标对象回溯到文档的根节点
    * 事件委托
        * 简单来讲，就是对父元素添加监听事件，这样利用冒泡机制，可以监听父元素内的所有元素的点击事件，之后使用e.target来判断具体点击的父元素中的哪个子元素。
    * 如何将事件申明为捕获
        * 使用addEventListener("click",callback,true),第三个参数是是决定冒泡还是捕获的，默认是false,即冒泡。
    * e.target与e.currentTarget
        * e.target:指向触发事件监听的对象
        * e.currentTarget:指向添加监听事件的对象
    * 使用e.stopPropagation()阻止事件捕获或冒泡
    * 使用e.preventDefault()阻止该事件的默认操作
2. 页面回流与重绘
    * 可详见有道云笔记的CSS章节回流与重绘
    * http://note.youdao.com/noteshare?id=67dcfd6e5e3d35dd647abe2f3cb22bcb&sub=8BCEE488991D4ED4B1552AF8860AC855
3. 浮动元素使其父元素高度塌陷
    * 原因：当元素设置浮动后，会自动脱离文档流；即当元素浮动后，就不在整个文档流的管辖范围，那么它之前存在在父元素内的高度就随着浮动不存在了，此时父元素会默认自己里面没有任何内容；当然，如果父元素设置了固定高度，那么父元素不会出现塌陷。
    * 解决方法(清除浮动)
        * 给父元素也添加float。使父元素和子元素一起脱离文档流浮动起来，保证子元素在父元素内，这样父元素就能自适应子元素的高度，但是该方法的弊端是父元素之后的元素排列，以及页面布局可能会受到影响。
        * 给父元素一个固定高度，适用于子元素高度已知且固定的情况
        * 添加一个块级元素，并给此元素设置clear:both;清除浮动。弊端：这会增加无意义标签。
        * 给父元素添加overflow:hidden
            * 隐藏溢出，当内容超过其父元素时，可以使用该属性和值将溢出的部分裁剪掉。
            * 当子元素浮动时，按照该属性，父元素需要将子元素超出的部分裁剪掉，但是因为子元素有浮动，无法裁剪，所以只能由父元素增加高度去包裹住子元素，而这个高度是跟随子元素自适应的高度，这样就把浮动的子元素包含在父元素内了。
        * 通过给父元素添加伪元素::after清除浮动
            * 使用伪元素来清除浮动，和在父元素中添加一个空div并将其设置成clear:both;是一样的，只不过这里使用伪元素代替了空的div元素。
4. 获取滚动条的宽度与高度
    * scrollTop：滚动条当前滚动的距离。
    * scrollHeight：滚动条可以滚动的距离。
    * 同理：scrollLeft和scrollWidth
    * 判断整个页面的滚动条，当页面具有DTD时，使用document.documentElement;当页面不具有DTD时，使用document.body。判断某个元素的滚动条时，直接document.getElementById("")或其他选择器。
    * 使用scrollHeight和scrollTop判断是否滚动到容器底部:scrollHeight=scrollTop+容器的高度(clientHeight)
5. DTD
    * DTD规定了标记语言的规则，这样浏览器才能正确地呈现内容。
    * <!DOCTYPE>声明；它不是HTML标签；是指示浏览器关于页面使用哪个HTML版本进行编写的指令。
    * <!DOCTYPE>声明必须是HTML文档的第一行，位于<html>标签之前。
    * 因为HTML4.01基于SGML，所以在HTML4.01中，需要<!DOCTYPE>声明引用DTD
    * HTML5不基于SGML,所以不需要引用DTD;但是，为了浏览器获知文档类型，请始终向HTML文档添加<!DOCTYPE>声明，HTML5中直接：<!DOCTYPE html>
## 2022-01-26
1. instanceof
    * 原理：用来判断实例对象的__proto__属性和构造函数的prototype属性是不是同一个引用。
    * 注意点：以[]为例，[].__proto__指向Array.prototype,而Array.prototype.__proto__又指向Object.prototype,因此[] instanceof Array是true，[] instanceof Object也是true，因此，instanceof只能用来判断两个对象是否属于实例关系，而不能判断一个对象实例具体属于哪种类型。
    * 与typeof的区别：typeof的返回值时一个字符串，用来说明对象的数据类型；instanceof的返回值时布尔值，用来判断一个变量是否属于某个对象的实例。
    * 直接使用"test String" instanceof String是false，必须先let testStr=new String();testStr instanceof String才是true。
2. typeof的结果
    * object：对象类型，包括（Object,Array,null）
    * undefined：未定义类型
    * string：字符串类型
    * number：数字类型
    * boolean：布尔类型
    * function：函数类型，包括（function,class）
3. 比较==，===，Object.is()的区别
    * ==：等同，比较运算符，两边值类型不同的时候，先进行类型转换，再比较
    * ===：恒等，严格比较运算符，不做类型转换，类型不同就是不等
    * Object.is()：ES6新增的用来比较两个值是否严格相等的方法，与===的行为基本一致
    * 对于使用同一个构造函数构造的对象，两个不相等的
    * 在===中：+0===-0；NaN!==NaN;但是Object.is()中，这两个是相反的
4. 构造函数以及原型链的一些方法
    * Object.assign()
        * Object.assign()：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象
        * Object.assign(target,...sources)  [target:目标对象]，[sources:源对象（可多个）]
        * 如果源对象中有重名的属性，后面的覆盖前面的
        * 只能复制可枚举的属性
        * Object.assign()是浅拷贝
        * 当原始类型作为源对象时，会被包装为对象，但通常只有字符串有课枚举属性，所以通常是只有字符串可以作为源对象。
    * Object.defineProperty()
        * Object.defineProperty()：直接在一个对象上定义新的属性或修改现有属性，并返回该对象。
        * Object.defineProperty(obj,key,prop):
            * obj：添加或修改属性的对象
            * key：添加或修改属性的名称
            * prop：添加或修改属性的具体参数对象
                * configurable：只有该参数为true时，属性后续才能修改或从对应对象中删除。默认false
                * enumerable：枚举属性。默认false
                * writable：只有该参数为true时，改属性的value后续才能修改。默认false
                * value：与属性关联的值，可以是任何有效的js值（数字，对象，函数等）。默认undefined
                * get：作为该属性的getter函数，如果没有getter，则为undefined。函数返回值将被用作属性的值。
                * set：作为该属性的setter函数，如果没有setter，则为undefined。函数将仅接受参数赋值给该属性的新值。
            * get与set通常用于数据处理，与其他4个参数分开。可参考：https://blog.csdn.net/weixin_34405354/article/details/94019810
        * 总结：
            * 在调用Object.defineProperty()创建一个新的属性时，如果不指定，默认configurable,enumerable,writable为false;使用Object.assign()创建时，默认为true。
            * 当wirtable为false且configurable为true时，value的值可以通过defineProperty修改，但是不能直接赋值修改
            * 可以通过writable:false和configurable:false创建一个真正的常亮属性
    * Object.defineProperties()
        * 和Object.defineProperty()一样的功能，用于批量新增修改属性
        * Object.defineProperties(obj,props)
            * obj：添加或修改属性的对象
            * props：{key1:prop1,key2:prop2}
        * 用法除了格式，其他和Object.defineProperty()相同
    * Object.getOwnPropertyDescriptor()
        * 获取对象某个属性的描述
        * Object.getOwnPropertyDescriptor(obj,key)
            obj：对象
            key：属性的名称，通常需要使用""
    * Object.getOwnPropertyDescriptors()
        * ES6中新引入的方法
        * 获取对象中所有属性的描述
        * Object.getOwnPropertyDescriptors(obj)
        * 引入该方式是由于使用Object.assign()的时候只可以复制可枚举类型，使用该方法可以配合Object.defineProperties()方法复制完整对象
        * Object.defineProperties(newObj,Object.getOwnPropertyDescriptors(obj))
    * Object.create()
        * 创建一个新对象，使用现有的对象来提供新创建对象的__proto__
        * Object.create(proto,[propertiesObject])
            * proto：必须。表示新建对象的原型对象，即该参数会被赋值到目标对象（最后返回的对象）的原型上。该参数可以是null、对象、函数的prototype属性。创建空对象时需要传null,否则会抛出异常。
            * [propertiesObject]：可选。添加到新创建对象的属性（其自身的属性，不是添加到原型链上的属性），类似于Object.defineProperties()中的第二个参数，因此也可以使用Object.getOwnPropertyDescriptors()
        * 具体使用：let newObj=Object.create(proto,[propertiesObject])
        * 通常完整的复制一个对象的方法：let newObj=Object.create(Object.getPrototypeOf(obj),Object.getOwnPropertyDescriptors(obj))
    * Object.setPrototypeOf()
        * 将一个指定对象的原型设置为另一个对象或null，即对指定对象的__proto__操作
        * Object.setPrototypeOf(obj,proto)
            obj：将被设置原型的对象
            proto：该对象新的原型
    * Object.getPrototypeOf()
        * 返回指定对象的原型
        * Object.getPrototypeOf(obj)
            * obj：要返回原型的对象
        * 返回值：给定对象的原型。如果没有继承属性，则返回null
        * 类似于obj.__proto__，但是建议还是使用Object.getPrototypeOf()
## 2022-01-27
1. js中的对象
    * 宿主环境：一般宿主环境由外壳程序创建和维护，只要能提供js引擎执行的环境都可称为外壳程序。比如：web浏览器，一些桌面应用系统等
    * 内部对象
        * 本地对象：
            * 独立于宿主环境的ES提供的对象
            * Object,Function,Array,String,Boolean,Number,Date,RegExp,Arguments,Error,EvalError,RangeError,ReferrnceError,SyntaxError,TypeError,URIError
            * ES6中新增：Symbol,Map,Set,Promise,Proxy
        * 内置对象
            * 独立于宿主环境，在ES程序开始执行时出现。
            * Math,Global(全局对象，isNaN()、parseInt()等方法都是全局对象的方法)
        * 内置对象都是本地对象，内置对象是本地对象的一种
    * 宿主对象
        * 执行JS脚本的环境提供的对象，对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象
        * 常用的：Window和Document等等
    * 自定义对象
        * 开发人员自己定义的对象。
2. 执行上下文/作用域/闭包
    * 执行上下文
        * 定义：当前js代码被解析和执行时所在的环境，所以通常也被称为执行上下文环境
        * 分类
            * 全局执行上下文：默认的，最基础的执行上下文。不在任何函数中的代码都位于全局执行上下文中。它做了两件事：1、创建一个全局对象，在浏览器中就是window对象；2、将this指针指向这个全局对象。一个程序中只能存在一个全局执行上下文。
            * 函数执行上下文：每次调用函数时，都会为该函数创建一个新的执行上下文。每个函数都有自己的执行上下文，但是只有函数被调用的时候才会被创建。一个程序中可以存在任意数量的函数执行上下文。
            * Eval函数执行上下文：运行在eval函数中的代码也获得了自己的执行上下文。
        * 执行上下文栈：
            * 执行全局代码时，会产生一个全局执行上下文，之后每次调用函数又会生成新的执行上下文环境
            * 当函数调用完成时，这个上下文环境以及其中的数据会被清除（闭包除外），处于活动状态的执行上下文环境只有一个。
            * 当有函数执行时，入栈一个新的上下文环境，该函数结束后，该上下文出栈。若函数中又执行新函数，则再次入栈新的执行上下文。处于活动状态的执行上下文环境只有栈顶的环境。
            * 具体入栈出栈可参考网址：https://segmentfault.com/a/1190000011843356
            * 函数在执行的过程中遇到return之后会终止可执行代码的执行，直接将当前的执行上下文弹出栈。
    * 作用域
        * 定义：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域的最大作用就是隔离变量，不同作用域下同名变量不会有冲突。
        * 分类
            * 全局作用域
            * 函数作用域
            * 块状作用域
            * 动态作用域（使用call,apply等修改this指向）
        * 作用域链：
            * 函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。
            * 当我们想要访问某一个变量或函数时，它会去当前作用域中查找，如果没有找到，那么它会去创建这个函数的父级作用域中查找，一直这样向上查找。我们把这种通过作用域采取链式查找的方式称为作用域链。
    * 执行上下文和作用域的区别
        * 作用域在解释阶段确定的，并且不会改变；执行上下文在运行阶段确定的，随时可能改变。
        * 作用域是静态观念的，执行上下文是动态的。
        * 作用域只是一个“地盘”，其中没有变量。变量是通过作用域对应的执行上下文环境中的变量对象来实现的。
        * 作用域中变量的值是执行过程中确定的，而作用于是在函数创建时就确定的。
    * 闭包
        * 定义：简单来讲，闭包就是能够读取其他函数内部变量的函数，定义在一个函数内部的函数。本质上，闭包就是就函数内部和函数外部连接起来的一座桥梁。
        * 使用：函数作为返回值；函数作为参数传递
        * 闭包的两个用途：读取函数内部的变量；让函数内部的变量的值始终保持在内存中。
        * 注意点：
            * 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包。同时，在IE中可能会导致内存泄露，解决方法：在退出函数之前，将不使用的局部变量删除，局部变量置null。
            * 闭包会在父函数外部，改变父函数内部的变量值。所以，如果你把父函数当做对象（class）使用，把闭包当做它的公有方法（public Method），把内部变量当做它的私有属性，这时需要注意不要随便改变父函数内部变量的值。
    * 参考网址
        * https://blog.csdn.net/ksjdbdh/article/details/120111962
        * https://segmentfault.com/a/1190000011843356
        * http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html
        * https://www.cnblogs.com/wangfupeng1988/p/3994065.html
3. 函数声明和函数表达式的区别
    * 函数声明：形如 function func(){}
    * 函数表达式：形如 var func=function(){}
    * 两个的区别：
        * 函数声明会有一个提升的过程，在作用域中无论在什么地方声明函数，都会默认提到作用域最上面，所以任何时候都可以调用。
        * 函数表达式没有提升的过程，所以必须等JS运行确认且赋值完成后，函数才能调用，调用代码必须放在函数表达式之后。
4. 垃圾回收机制
    * 可达性：js中内存管理的主要概念是可达性。
        * 简单来讲，可达性就是那些以某种方式可访问或可用的值，它们被保证存储在内存中。
    * 有一组基本的固有可达值，由于显而易见的原因无法删除，简单归类就是js对象中的内部对象和宿主对象，这些值称为根。
        * 本地函数的局部变量和参数
        * 当前嵌套调用链上的其他函数的变量和参数
        * 全局变量
        * 还有一些其他的，内部的
    * 如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的。
    * js引擎中有一个后台进程称为垃圾回收器，它监听所有对象，并删除那些不可访问的对象。
        * 内部算法：“标记-清除”，定期执行以下“垃圾回收”步骤
            * 垃圾回收器获取根并“标记”它们。
            * 访问并“标记”所以来自根的引用。
            * 访问标记的对象并标记它们的引用，所有被访问的对象都被记住，以便以后不再访问同一个对象两次。
            * 以此类推，知道有未访问的引用为止。
            * 除了标记的对象外，所有对象都被删除。
        * js引擎对回收的优化
            * 分代回收：对象分为两组：“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结束，它们很快就会被清理干净。那些活的足够久的对象，会变老，并且很少接受检查
            * 增量回收：如果有很多对象，引擎会将垃圾回收分解为多个部分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，而不是很大的延迟。
            * 空闲时间收集：垃圾回收器只在CPU空闲时运行，以减少对执行的可能影响。
    * 总结：
        * 一般来说，没有被引用的对象就是垃圾，就要被清除。有个例外，如果几个对象互相引用形成一个环，但是根访问不到它们，那这几个对象也是垃圾，也要被清除。
        * 删除变量的方法
            * 直接赋值null
            * 对于对象中的属性，可以使用delete
5. 函数与变量的提升
    * 当使用var定义变量，以及使用函数声明时，js引擎会将所有变量声明和函数声明提升到全局作用域的顶端
    * 变量提升时，只是提升变量声明，并不将赋值也提升
    * 函数声明提升之后在变量提升的位置之前
    * let 不存在变量提升情况
6. let与var声明的全局变量
    * let声明的全局变量，不会成为window的属性
    * var声明的全局变量，会称为window的属性
7. this
    * 可详见有道云笔记的js章节中的this
    * http://note.youdao.com/noteshare?id=e959f57472f9b6c7a31e13b46b58ec6d&sub=B97ADF7A17F74F968D3A6A3D5CA4723C
## 2022-01-28
1. ajax,axios,fetch
    * ajax
        * 传统ajax：指的是XMLHttpRequest(XHR),最早出现的发送后端请求技术
        * jquery中的ajax：对原生XHR的封装
            * 缺点：
                * 本身是针对MVC的编程，不符合现在前端MVVM的浪潮
                * 基于XHR开发，XHR本身的架构不清晰
                * 通常使用ajax,都是使用jquery封装的ajax,但是为了使用ajax而引入整个jquery非常不合理
                * 不符合关注分离的原则
                * 配置和调用方式很混乱，而且基于事件的异步模型不友好。

        * 回调地狱：
            * 由于某些业务的的需要，每个接口都要依赖前一个接口的返回，在代码中一次性写多层的回调嵌套，回调嵌套后的代码维护难度无法快速排除BUG。
            * 解决方法：使用ES6中的Promise或者async
    * axios
        * 本质上也是对原生XHR的封装，只不过它是Promise的实现版本
        * 特性：
            * 从浏览器中创建XMLHttpRequest
            * 支持Promise API
            * 客户端支持防止CSRF:让你的每个请求都带一个从cookie中拿到的key,根据浏览器同源策略，冒充的网站是拿不到cookie中的key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入。
            * 提供了一些并发请求的接口（方便了很多的操作）
            * 从node.js创建http请求
            * 拦截请求和响应
            * 转换请求和响应数据
            * 取消请求
            * 自动转换JSON数据
        * 由于axios还是对原生XHR的封装，所以使用时还是要导入第三方包
    * fetch
        * 号称是ajax的替代品，ES6新增的，使用了ES6中的promise对象。
        * fetch不是ajax的进一步封装，而是原生js，没有使用XHR
        * 优点：
            * 语法简洁，更加语义化
            * 基于标准Promise实现，支持async/await
            * 同构方便
            * 更加底层，提供的API丰富
            * 脱离了XHR,是ES规范里新的实现方式
        * 存在的问题
            * fetch只对网络请求报错，400和500都当做成功的请求；当服务器返回400和500的时候，并不会reject；只有网络错误这些导致请求不能完成时，fetch才会被reject。
            * fetch默认不会带cookie，需要添加配置项:fetch(url,{credentials:'include'})
            * fetch不支持abort，不支持超时控制，使用setTimeout和Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成流量的浪费
            * fetch没有办法原生监测请求的进度，而XHR可以
    * 总结：axios既提供了并发的封装，也没有fetch的各种问题，而且体积也比较小，当之无愧现在最应该选用的请求方式
    * 代码
        ```javascript
            //ajax
            function testAjax(){
                $.ajax({
                    url:'/web/case_data/filed_patient_list_data',
                    data:{
                        institutionCode,
                        patientName:'',
                        page:1,
                        limit:15
                    },
                    type:'POST',
                    success:function(res){
                        console.log("ajax调用接口的结果：",res)
                    }
                })
            }
            //axios
            function testAxios(){
                axios({
                    method:'POST',
                    url:'/web/case_data/filed_patient_list_data',
                    data:Qs.stringify(
                        {
                            institutionCode,
                            patientName:'',
                            page:1,
                            limit:15
                        }
                    )
                }).then(res=>{
                    console.log("axios调用接口的结果：",res)
                }).catch(err=>{
                    console.log("axios调用接口的错误：",err)
                })
            }
            //fetch(此处是将fetch使用Promise封装了)
            function fetchMethod(url,data,method,contentType){
                return new Promise((resolve,reject)=>{
                    fetch(url,{
                        method,
                        headers: {
                            'Content-Type': contentType?contentType:'application/x-www-form-urlencoded'
                        },
                        body:Qs.stringify(data)
                    }).then(res=>res.json()).then(res=>{
                        resolve(res)
                    }).catch(err=>{
                        reject(err)
                    })
                })
            }
        ```
## 2022-01-30
1. 暂时性死区(TDZ)
    *  在运行流程进入作用域创建变量，到变量可以访问之间的这段时间，称之为暂时性死区。 个人理解：使用let,const创建变量时，在未定义之前就使用。
    *  主要原因：ES6新增的let,const关键字声明的变量会产生块级作用域，如果变量在当前作用域中被创建之前被创建出来，由于此时还没有完成语法绑定，如果此时访问变量，就会产生暂时性死区的问题
    * 会引发暂时性死区的用法
        * let,const
        * typeof
        * import
        * class
## 2022-02-06
1. JSON.stringify()
    * 第二个参数
        * 作用：用于过滤，格式化
        * 形式：
            * null：无变化
            * 数组：key的数组，表示只获取这些key的键值对。
            * 函数：(key,value)=>{};
                * 对于return undefined的属性会忽略
                * 可使用return对value进行批量化修改（不确定key能不能修改）
                * 遍历对象，只有有return时，才会遍历所有键值对，否则只遍历本身对象。
    * 第三个参数
        * 作用：用于缩进
        * 形式：
            * null：无变化
            * 数字：缩进多少个空格，最大10，小于1没有空格
            * 字符串：作为缩进使用
2. 深拷贝
    * JSON.parse(JSON.stringify(obj))
        * 对于undefined，和function无法拷贝
        * 有时间对象的话，时间对象=>字符串形式
        * NaN、Infinity和-Infinity会被转化成null
        * RegExp和Error会被转化成空对象
        * 如果对象是由构造函数生成的，会丢弃对象的constructor
        * 对于循环引用的情况无法深拷贝
    * 递归函数实现
        * 相关代码
            ```javascript
                function deepClone(obj){
                    let retObj;
                    if(Object.prototype.toString.call(obj)==='[object Object]'){
                        retObj={};
                        for (const key in obj) {
                            retObj[key]=deepClone(obj[key])
                        }
                    }else if(Object.prototype.toString.call(obj)==='[object Array]'){
                        retObj=[];
                        for (const key in obj) {
                            retObj.push(deepClone(obj[key]))
                        }
                    }else{
                        retObj=obj;
                    }
                    return retObj;
                }
            ```            
3. toString()的几种用法
    * 数字转字符串
    * 获取对象的字符串
    * Object.prototype.toString.call()
        * 可用于判断变量的类型，比typeof和 instanceof更准确
4. 使用解构封装url参数
    * 个人代码
        ```javascript
            function urlToJson(url){
                let[,dataStr='']=url.split("?")
                let dataArr=dataStr.split("&")
                let retJson=new Object();
                dataArr.forEach(item=>{
                    let[key,value='']=item.split("=")
                    retJson[key]=value;
                })
                return retJson;
            }
        ```
## 2022-02-07
1. 圣杯布局和双飞翼布局
    * 功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局
    * 圣杯布局:
        * 来源于文章In Search of the Holy Grail
        * 页面大致布局
            ```html
            <div class="contain">
                <div class="center"></div>
                <div class="left"></div>
                <div class="right"></div>
            </div>
            ```
        * 要点：
            * contain需要加overflow:hidden清除浮动
            * center,left,right需要设置float:left
            * center需要设置width:100%
            * left,right需要设置负边距（margin-left:-xxx）
            * contain需要设置左右padding
            * left,right最终需要设置position:relative
    * 双飞翼布局：
        * 来源于淘宝UED
        * 页面大致布局
            ```html
            <div class="contain">
                <div class="center"></div>
            </div>
            <div class="left"></div>
            <div class="right"></div>
            ```
        * 要点：
            * contain,left,right需要设置float:left
            * left,right需要设置负边距（margin-left:-xxx）
            * center设置左右margin
    * 总结
        * 圣杯布局在DOM结构上更直观
        * 双飞翼布局在实现上不需要绝对定位
    * 其他实现方式
        * 使用calc计算center需要的宽度
        * 使用box-sizing:border-box
            * 在圣杯布局Dom中，contain取消padding，在center中加padding和box-sizing
            * 这样left和right就可以取消position:relative
        * flex布局
## 2022-02-08
1. BFC
    * Block Formatting Context 块级格式化上下文
    * 一个BFC区域包含创建该上下文元素的所有子元素，但是不包括创建了新的BFC的子元素的内部元素
        * 每一个BFC区域只包括其子元素，不包括其子元素的子元素。
        * 每一个BFC区域都是独立隔绝的，互不影响
    * BFC布局规则
        * 内部的Box会在垂直方向，一个接一个地放置。
        * Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。
        * 每个盒子（块盒和行盒）的margin box的左边，与包含块border box的左边想接触（对于从左往右的格式化，否则相反）。即使浮动也是如此。即左对齐
        * BFC的区域不会与float box重叠。
        * BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，外面的也不会影响到里面。
        * 计算BFC的高度时，浮动元素也参与计算。
    * 如何创建BFC
        * float的值不是none
        * position的值不是static或者relative
        * display的值是inline-block,table-cell,flex,table-caption或者inline-flex
        * overflow的值不是visible
    * BFC的作用
        * 利用BFC避免margin重叠：将两个重叠的块放进两个不同的BFC区域中
        * 自适应两栏布局：根据BFC区域不会与float box重叠，激活左栏或右栏的BFC，使其与另一个float栏不重叠
        * 清除浮动：根据计算BFC的高度时，浮动元素也参与计算，所以激活父元素的BfC（overflow:hidden）
    * 参考网址：https://blog.csdn.net/sinat_36422236/article/details/88763187
2. IFC
    * Inline-Formatting-Contexts 内联格式化上下文布局
    * 形成条件：块级元素中仅包含内联元素。当IFC中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个IFC。
    * 布局规则
        * 子元素水平方向横向排列，且垂直方向起点为元素顶部。
        * 子元素只会计算横向样式空间，[padding、border、margin],垂直方向不会被计算。
        * 在垂直方向上，子元素会以不同形式来对齐（vertical-align）
        * 能把在一行上的框完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是由包含块（containing box）和其中的浮动来决定的
        * IFC中的“line box”一般左右边贴紧其包含块，但float元素会优先排列。
        * IFC中的“line box”高度由css行高计算规则来确定，同个IFC下的多个line box高度可能会不同。
        * 当inline-level boxes的总宽度少于包含它们的line box时，其水平渲染规则由text-align属性值决定。
        * 当一个inline box超过其父元素的宽度时，它会被分割成多个boxes,这些boxes分布在多个line box中。如果子元素未设置强制换行的情况下，inline box将不可分割，将会溢出父元素。
    * 参考网址：https://segmentfault.com/a/1190000017273573
3. Event Loop
    * 事件轮循（事件循环）是一个很重要的概念，指的是计算机系统的一种运行机制。javascript语言就是采用这种机制，来解决单线程运行带来的一些问题。
    * 宏队列与微队列
        * 宏队列：macrotask，也叫tasks。一些异步任务的回调会依次进入macro task queue，等待后续被调用，包括如下：
            * setTimeout、setInterval、I/O
            * 浏览器独有：requestAnimationFrame（动画执行）、UI rendering
            * node独有：setImmediate
        * 微队列：microtask，也叫jobs。另一些异步任务的回调会依次进入micro task queue，等待后续被调用，包括如下：
            * Promise、Object.observe（监听对象）、MutationObserver（监听Dom树）
            * node独有：process.nextTick
    * 浏览器中的Event Loop
        * 执行步骤：
            * 执行全局script同步代码，(这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）:暂不理解)；
            * 全局script代码执行完毕后，调用栈stack会清空；
            * 从微队列中取出队首的回调任务，放入调用栈中执行，执行后队列长度减1；
            * 继续取出微队列队首的回调任务，放到调用栈中执行，以此类推，直到微队列中所有任务执行结束；
            * 微队列中任务全部完成后，微队列为空，调用栈为空；
            * 取出宏队列中的队首回调任务，放入调用栈中执行；
            * 执行结束后，去微队列中看看有没有新的回调任务，如果有，则继续从微队列队首取回调任务，直至微队列清空；如果没有，则取宏队列队首的回调任务，放入调用栈。
            * 执行结束后，重复上述步骤，去微队列中去看看有没有新的回调任务。
        * 注意点：
            * 当在执行微队列中的回调任务时，产生新的微任务，继续放进微队列中，在本次执行周期中完成。
            * 宏队列每次执行的时候，只取队首的任务，执行完成后就判断微队列。
            * 微队列中每次都是所有任务都执行完成后，才会去宏队列中取宏队列队首的任务。
            * 浏览器会自行判断UI rendering，在执行完所有的微任务之后，下一次宏任务之前，紧跟着本轮的UI render。
    * node中的Event Loop
## 2022-02-18
1. Object.entries()
    * 方法返回一个给定对象的可枚举属性的键值对数组，简单来讲就是把一个对象的键值以数组的形式遍历出来
    * 常用：
        * 对象：{foo:'bar',baz:'abc'} ===> [['foo','bar'],['baz','abc']]
        * 数组：
            * 纯基本类型数组：[1,2,3] ===> [['0',1],['1',2],['2',3]]
            * 数组中包含对象：[1,{a:1}] ===> [['0',1],['1',{a:1}]]
        * 字符串：'123' ===> [['0',1],['1',2],['2',3]]
        * 数字，浮点数 ===> []
    * 使用该方法可以将Object方便的转化成Map
        * new Map()构造函数接受一个可迭代的entries。
        * 代码：
        ```javascript
            const obj2={foo:'bar',baz:'abc'}
            const map=new Map(Object.entries(obj2));
        ```
2. 遍历
    * for循环
        * 传统的循环
        * 代码
            ```javascript
            let arr=[1,2,3];
            for(let i=0;i<arr.length;i++){
                console.log(arr[i])
            }
            ```
    * for...in
        * 常用于遍历对象
        * 也可以用于遍历数组，但会存在以下问题
            * 数组的index会被默认为key
                * [1,2,3] 会被默认为 {"0":1,"1":2,"2":3}
            * 遍历顺序可能不是按照实际数组的内部顺序
        * 使用for...in遍历会会遍历所有的可枚举属性，包括原型
        * 代码
            ```javascript
            //对象
            let obj1={a:1,b:2,c:3}
            for(let i in obj1){
                console.log(i);         //"a"
                console.log(obj1[i]);   //1
            }
            //数组
            let obj2=[1,2,3]
            for(let i in obj2){
                console.log(i)          //"0"
                console.log(obj2[i])    //1
            }
            //含有可枚举原型的对象(此时会将原型中的可枚举属性也遍历出来)
            let obj3={a:1,b:2,c:3}
            obj3.__proto__.d1='hhh' //此处这样添加原型会直接添加到Object.prototype上
            for(let i in obj3){
                console.log(i)
                console.log(obj3[i])
            }
            ```
    * for...of
        * 与for...in的区别
            * for...of无法遍历循环对象
            * for...of返回的是数组的值，而for...in返回的是数组的键值（索引）
            * for...of不会遍历原型上的可枚举属性
        * 使用
            * for(let val of arr)
            * for(let index of arr.keys())
            * for(let item of arr.entries())
            * for(let [index,val] of arr.entries())
        * 备注
            * 可详见有道云笔记中的数组遍历章节
            * http://note.youdao.com/noteshare?id=e6d1109873b99295e0a57b6ad5194f13&sub=B7AAB90B252A40E2996617A31F0D124D
    * forEach,map,every,some,find,filter
        * 可详见有道云笔记中的数组遍历章节
    * reduce,reduceRight
        * 可详见有道云笔记中的数组遍历章节
3. const
    * 使用const定义的基本数据类型不可修改
    * 使用const定义的对象可以修改，因为引入的只是一个地址，要想完全不可修改，可使用Object.freeze();
    * 通常使用const来定义自己写的方法库或者某个组件(自己不想被别人修改的东西)  
4. script 标签中 defer 和 async 的区别
    * 默认情况下，浏览器是同步加载js脚本，即遇到```<script>```标签会停下来，等到执行完脚本，再继续向下渲染，如果是外部脚本，还必须加入脚本下载的时间。因此可以使用defer和async修饰
    * 两者区别：
        * defer：要等到整个页面在内存中正常渲染结束（DOM结构完全生成，以及其他脚本执行完成），才会执行，即渲染完再执行。对于多个defer脚本，会按照在页面中出现的顺序加载。
        * async：一旦下载完，渲染引擎就会中断渲染，执行这个脚本后，继续渲染，即下载完就执行。对于多个async脚本，不能保证加载顺序。
    * 总结：
        * 相同点：
            * 两者都是异步加载
            * 对于inline的script无效
        * 不同点：
            * 执行脚本：defer是渲染完再执行；async是下载完就执行。
            * 加载顺序：defer会按照页面中出现的顺序加载；async不能保证加载顺序。
        * 使用：
            * 测试的时候直接在```<script defer>代码段</script>```中无效果，只有src中才有。
            * 将脚本放在```</body>```前面，有依赖的话按照顺序放好。
            * 如果一定要放在head标签里面，最好加上defer属性。
    * 参考网址：
        * https://blog.csdn.net/weixin_42561383/article/details/86564715
        * https://segmentfault.com/a/1190000006778717
## 2022-02-21
1. MVC和MVVM
    * MVC(Model View Controller)
        * 相关单词介绍
            * Model：
                * 模型层，是应用程序用于处理应用程序数据逻辑的部分，及数据。通常模型对象负责在数据库中存取数据。
                * 例如js中对数据的处理与操作
            * View：
                * 视图层，用户界面渲染逻辑，及我们通常见到的html代码（个人理解）。通常视图是依据模型数据创建的。
                * 例如页面中的html与css代码
            * Controller：
                * 控制器，数据模型和视图之间通信的桥梁，通常控制器负责从视图读取数据，控制用户输入，向模型层发送数据。
                * 例如js中的各种因html触发的事件
        * 思想
            * Model驱动View，View动作指令给Controller,Controller选择模型Model
            * Controller负责将Model的数据用View显示出来，及在Controller中把Model的数据赋值给View
        * 特点
            * 实现关注点分离，将模型与视图之间实现代码分离。
    * MVVM(Model View ViewModal)
        * 相关单词介绍
            * Model
                * 模型，指的是后端传递的数据。
                * 在Vue中相当于data中的数据
            * View
                * 视图，可见的页面
                * 在Vue中相当于模板
            * ViewModal
                * 视图模型，mvvm模式的核心，是连接view和model的桥梁。主要用来处理业务逻辑
                * 在Vue中想当于Vue实例
        * 思想
            * View和ViewModal数据绑定；ViewModal中处理业务逻辑，以及对底层数据Model进行修改；Model将数据给ViewModal;
            * 两个方向(数据双向绑定)
                * 将Model转化为View:ViewModal将后端传递的数据转化为所见到的页面的方式是：数据绑定
                * 将View转化为Model:将所见到的页面转化为后端的数据的方式是：DOM事件监听
        * 特点：
            * View和Model是不能直接通信的，它们通过ViewModal来通信。Model改变，ViewModal通知View自动更新；用户操作View,ViewModal通知Model做改动。
            * View和ViewModal可以互相通信。
        * 主流使用：Vue，angular
    * MVC和MVVM的区别
        * 简单来讲：mvc是单向数据改变，默认只是Model的改变，控制View；而mvvm是双向的，Model和View自动更新
        * MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验
    * 参考网址：
        * https://blog.csdn.net/qq_42033567/article/details/107897148
2. 数据代理
    * 通过一个对象代理另一个对象中的属性的操作（读/写）
    * 这样对对象的操作会映射到代理的对象上。对象修改，代理的对象相应修改
    * 实现方法
        * 使用Object.defineProperty(),或者Object.defineProperties()中的getter/setter实现
        * 使用ES6中的Proxy对象
    * 相关代码
        * 使用Object.defineProperty()等方法
        ```javascript
            let obj1={name:'hhh',age:12};
            //使用Object.defineProperty()
            let obj2={};
            Object.defineProperty(obj2,'name',{
                get(){
                    return obj1.name
                },
                set(value){
                    obj1.name=value
                }
            })
            //使用Object.defineProperties()
            let obj3={};
            Object.defineProperties(obj3,{
                name:{
                    get(){return obj1.name},
                    set(value){obj1.name=value}
                },
                age:{
                    get(){return obj1.age},
                    set(value){obj1.age=value}
                }
            })

        ```
        * 使用Proxy
        ```javascript
            let obj={name:'hhh',age:12};
            let testObj=new Proxy(obj,{
                get(target,property){
                    console.log("获取了对象的属性：",property)
                    return target[property]
                },
                set(target,property,value){
                    console.log("设置对象的属性：",property)
                    target[property]=value
                }
            })
        ```
## 2022-02-22
1. margin在竖直方向重叠问题（边距折叠）
    * 原因：
        * margin折叠：块的顶部和底部边距有时会组合折叠成单个边距，其大小是各个边距中最大的一个（或者只是其中一个，如果他们相等）
    * 三种基本情况
        * 相邻的兄弟姐妹
        * 没有分隔的父子
        * 空块(没有border,padding,内联元素,height,minheight)
    * 负边距
        * 正边距和负边距都有：两个元素之间的距离：正边距+负边距
        * 都是负边距：两个元素之间的距离：取绝对值最大的负边距
    * 解决方法
        * 相邻的兄弟姐妹
            * 使用两个div包裹起来(包裹的两个div要符合BFC布局条件)，使其分属于不同的BFC
            * 子元素添加float:left
            * 子元素添加position:absolute
            * 子元素添加display:inline-block
        * 没有分隔的父子
            * 在父元素上设置border或padding
            * 将父元素设置成BFC（这样父元素和子元素就属于不同的两个BFC）
        * 空块
            * 在空块上设置border,padding,height,min-height
            * 将空块设置成BFC
    * 参考网址：https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing
2. 盒模型
    * 盒子的组成部分
        * content：内容
        * padding：内边距
        * border：边框
        * margin：外边距
    * CSS盒模型和IE盒模型的区别
        * 在标准盒模型中，width和height指的是内容的宽度和高度。增加内边距，边框，外边距不会影响内容区域的尺寸，但是会增加整个元素框的总尺寸。
        * 在IE盒模型中，width和height指的是content+padding+border的宽度和高度。增加内边距和边框，会是内容区域变小。
    * box-sizing属性
        * 规定宽度和高度的计算方式
        * 值
            * content-box：个人理解就是相当于采用标准盒模型，宽度和高度时元素的内容的宽度和高度
            * border-box：个人理解就相当于采用IE盒模型，宽度和高度是content+padding+border的宽度和高度
            * inherit：规定从父元素继承box-sizing属性的值
3. 块级元素和行内元素
    * 块级元素
        * 特点
            * 块级元素会独占一行
            * 高度，行高，外边距和内边距都可以单独设置
            * 宽度默认是容器的100%
            * 可以容纳内联元素和其他块级元素
        * 常见的块级元素
            ```html
                <h1></h1> ..... <h6></h6>
                <p></p>
                <div></div>
                <ul></ul>
                <ol></ol>
                <li></li>
            ```
    * 行内元素（内联元素）
        * 特点
            * 和相邻的行内元素在一行上
            * 高度和宽度无效，但水平方向上的padding和margin可以设置，垂直方向上的无效
            * 默认的宽度就是它本身的宽度
            * 行内元素只能容纳纯文本或者是其他的行内元素（a标签除外）
        * 常见的行内元素
            ```html
                <span></span>
                <a></a>
                <strong></strong>
                <b></b>
                <em></em>
                <del></del>
            ```
    * 行内替换元素(行内块级元素)
        * 特点
            * 和相邻的行内元素（行内块）在一行上，但是中间会有空白的间隙
            * 默认的宽度就是本身内容的宽度
            * 高度，行高，内边距和外边距都可以设置
        * 常见
            ```html
                <img/>
                <input/>
                <textarea></textarea>
                <select></select>
                <td></td>
            ```
    * 显示模式的转换
        * 块转行内：display:inline;
        * 行内转块：display:block;
        * 块，行内元素转换为行内块：display:inline-block;
4. CSS选择器和优先级
    * CSS的三大特性
        * 继承：子类继承父类的样式
        * 优先级：不同类别样式的权重比较
        * 层叠：当数量相同时，通过层叠（后者覆盖前者）的样式
    * 优先级：
        * 不同级别：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性
        * 相同级别：后写的会覆盖先写的样式
    * 参考网址：https://www.cnblogs.com/zxjwlh/p/6213239.html
## 2022-02-23
1. 迭代器(Iterator)与生成器(Generator)
    * 引入原因：
        * 用循环语句迭代数据时，需要初始化一个变量来记录每一次迭代在数据集合中的位置，虽然语法简单，但是如果多个循环嵌套，那么需要追踪多个变量，一不小心会错误的使用其他for循环中的变量。
        * 而使用迭代器可以极大的简化数据操作。迭代器的出现就旨在消除这种复杂性并减少循环中的错误
    * 迭代器
        * 迭代器是一种特殊对象，
        * 所有的迭代器对象都有一个next()方法，每次调用都返回一个结果对象：{value:xxx,done:boolean}
            * value：表示下一个将要返回的值；当没有更多可以返回的数据时，将会返回undefined。
            * done：布尔类型，当没有更多可以返回的数据时，返回true。
        * 迭代器会保存一个内部指针，用来指向当前集合中值得位置，每调用一次next()方法，都会返回下一个可用的值。
        * 简单的ES5创建的迭代器
            ```javascript
                function createIterator(items) {
                    var i = 0;
                    return {
                        next: function() {
                            var done = (i >= items.length);
                            var value = !done ? items[i++] : undefined;
                            return {
                                done: done,
                                value: value
                            };
                        }
                    };
                }
                var iterator = createIterator([1, 2, 3]);
                iterator.next();
            ```
        * 在ES6中引入了生成器的概念，用来返回迭代器
    * 生成器
        * 生成器就是一种返回迭代器的函数，通过function关键字后面的*来表示，函数中也会用到新的关键字yield。
            * 星号可以紧挨着function关键字，也可以在中间添加一个空格
            * 代码示例：
                ```javascript
                    function *createIterator(){ //或者function*createIterator
                        yield 1;
                        yield 2;
                        yield 3;
                    }
                    let iterator=createIterator();
                    iterator.next();
                    iterator.next();
                ```
            * 每当执行完一条yield语句后函数就会自动停止执行，直到再次使用迭代器的next()方法才会继续执行
            * 使用限制：
                * yield关键字只能在生成器内部使用，在其他地方使用会导致程序抛出错误
            * 使用方式
                * 直接使用
                    ```javascript
                        function *createIterator(){}
                    ```
                * 函数表达式
                    ```javascript
                        let createIterator=function *(){}
                    ```
                * 对象中使用
                    ```javascript
                        let obj={
                            createIterator:function *(){},
                            *createIterator2(){}
                        }
                    ```
            * 常规用法
                * 对对象生成迭代器函数
                    ```javascript
                        function *createObjectIterator(obj){
                            for(let key in obj){
                                yield obj[key]
                            }
                        }
                        let testObj={a:1,b:2,c:{dd:1,ee:2}}
                        let iterator=createObjectIterator(testObj)
                        iterator.next();
                        iterator.next();
                    ```
                * 状态机
                    ```javascript
                        let state=function *(){
                            while(1){
                                yield 'A';
                                yield 'B';
                                yield 'C';
                            }
                        }
                        let status=state();
                        status.next();
                        status.next();
                    ```
    * 可迭代对象
        * 可迭代对象具有Symbol.iterator属性。
            * 是一种与迭代器密切相关的对象。
            * Symbol.iterator通过指定的函数可以返回一个作用于附属对象的迭代器。
            * 由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都是可迭代对象
                * 示例代码
                    ```javascript
                        function * testGen(){
                            yield 1;
                            yield 2;
                            yield 3;
                        }
                        for(let i of testGen()){console.log(i)}
                        let [a,b,c]=testGen();
                        let [a,...b]=testGen();
                        [...testGen()];
                        //注意，必须直接写函数，如果写表达式let test=testGen()，那么经测试只可以遍历一次，即test只可以测试一次迭代效果。
                    ```
        * 可迭代对象
            * 集合对象：数组，Set集合，Map集合
            * 字符串
            * 浏览器中NodeList(节点,document.getElementsByTagName("div"))
        * 可迭代对象可以被for...of和扩展运算符...使用
            * for...of遍历原理
                * 判断遍历对象中是否有Symbol.iterator属性
                * 每循环一下调用一下可迭代对象迭代器的next()方法
                * 将迭代器返回的结果对象的value存储在一个变量中
                * 循环持续到迭代器结果对象的done为true
            * 与传统的for循环相比，去除了引入变量跟踪索引的方式
            * 使用扩展运算符可以将所有非数组类型的可迭代对象转化为数组
                * 代码示例
                   ```javascript
                        [..."123"]
                        [...new Set([1,2,3,4,4,5])]
                    ``` 
        * Symbol.iterator
            * 可迭代对象都有Symbol.iterator属性
            * 用途：
                * 访问默认迭代器
                    * 代码示例
                        ```javascript
                            let array=[1,2,3]
                            let iterator=array[Symbol.iterator]()   //是一个函数，所以要调用
                            iterator.next();
                            iterator.next();
                        ```
                * 判断对象是否为可迭代对象
                    * 代码示例
                        ```javascript
                            function isIteratorObj(obj){
                                return typeof obj[Symbol.iterator]==="function";
                            }
                        ```
                * 创建可迭代对象
                    * 正常情况下，开发者定义的对象都是不可迭代对象，但如果给定义的对象添加Symbol.iterator属性，并且给该属性添加一个生成器，那么该对象可变成可迭代对象。
                    * 代码示例：
                        ```javascript
                            let testObj={
                                a:1,
                                b:'111',
                                c:[1,2,3],
                                d:{dd1:11,dd2:22},
                                e:function(){console.log(111)},
                                f:[{ffa:1,ffb:2},{ffa:2,ffb:3}],
                                *[Symbol.iterator](){
                                    for(let key in this){
                                        yield this[key]
                                    }
                                }
                            }
                            for(let i of testObj){console.log(i)}
                        ```
    * 内建迭代器
        * 在ES6中，已经为许多内建类型提供了内建的迭代器，只有当这些内建的迭代器无法满足时，才需要额外自己写迭代器。
        * 常见的内建迭代器
            * 集合对象（数组、Set集合、Map集合）迭代器
                * entries() 返回一个迭代器，其值为多个键值对
                    * 代码示例
                        ```javascript
                            let arrayIterator=[1,2,3].entries();  
                            for(let i of arrayIterator){console.log(i)};        //返回[0,1][1,2][2,3];第一个元素是数字类型的索引，第二个是值

                            let setIterator=new Set([1,2,3]).entries();
                            for(let i of setIterator){console.log(i)};          //返回[1,1][2,2][3,3];第一个元素和第二个元素都是值，Set中的值被作为键和值同时使用

                            let testMap=new Map();
                            testMap.set("a",'1');
                            testMap.set("b",'2');
                            testMap.set("c",'3');
                            let mapIterator=testMap.entries();
                            for(let i of mapIterator){console.log(i)};          //返回['a','1']['b','2']['c','3'];第一个元素是键名，第二个元素是值
                        ```
                * values() 返回一个迭代器，其值为集合的值
                * keys() 返回一个迭代器，其值为集合的所有键名
                * 不同集合类型的默认迭代器
                    * 在for...of循环中，如果没有显式指定则使用默认的迭代器。
                    * 数组和Set集合的默认迭代器是values();Map集合的默认迭代器是entries()方法。
                    * 示例代码
                        ```javascript
                            let tempArray=[1,2,3]
                            for(let value of tempArray){console.log(value)}     //未指定的情况下数组默认是values()
                        ```
                * WeakSet集合和WeakMap集合没有内建的迭代器。
            * 字符串迭代器
                * 类似于数组，但是没有entries(),values(),keys()这些，只可以直接使用for...of
            * NodeList迭代器
                * 类似于数组，但是没有entries(),values(),keys()这些，只可以直接使用for...of
    * 高级迭代器
        * 给迭代器传递参数
            * 迭代器既可以用迭代器的next()方法返回值，同时也可以在生成器内部使用yield关键字来生成值。
            * 使用next传参
                * 使用迭代器的next()方法传递参数，则这个参数的值就会替代生成器内部 ==上条yield语句== 的返回值。
                * 第一次调用next()方法时无论传入什么参数都会被丢弃
            * 示例代码
                ```javascript
                    function *createIterator() {
                        let first = yield 1;
                        let second = yield first + 2; // 4 + 2
                        yield second + 3; // 5 + 3
                    }
                    let iterator = createIterator();
                    console.log(iterator.next()); // "{ value: 1, done: false }"
                    console.log(iterator.next(4)); // "{ value: 6, done: false },此处的4给上一条yield作为返回值"
                    console.log(iterator.next(5)); // "{ value: 8, done: false }"
                    console.log(iterator.next()); // "{ value: undefined, done: true }"
                ```
        * 在迭代器中抛出错误
            * 在迭代器中还可以给它传递错误条件。通过throws()方法，当然，这个错误可以在生成器中使用try-catch包裹。
            * 示例代码
                ```javascript
                    function *createIterator() {
                        let first = yield 1;
                        let second = yield first + 2; // yield 4 + 2 ，然后抛出错误
                        yield second + 3; // 永不会被执行
                    }
                    let iterator = createIterator();
                    console.log(iterator.next()); // "{ value: 1, done: false }"
                    console.log(iterator.next(4)); // "{ value: 6, done: false }"
                    console.log(iterator.throw(new Error("Boom"))); // 从生成器中抛出了错误
                ```
        * 生成器返回语句
            * 在生成器中可以使用return语句提前退出函数执行，对于最后一次next()方法调用，可以主动为其指定一个返回值。
                * return 表示所有操作已经完成，属性done被设置成true;如果同时提供了相应的值，则属性value会被设置成这个值。
                * 示例代码
                    ```javascript
                        function *createIterator() {
                            yield 1;
                            return 42;
                            yield 2;
                        }
                        let iterator = createIterator();
                        console.log(iterator.next()); // "{ value: 1, done: false }"
                        console.log(iterator.next()); // "{ value: 42, done: true }" 涉及到return，done变成true
                        console.log(iterator.next()); // "{ value: undefined, done: true }"
                        console.log(iterator.next()); // "{ value: undefined, done: true }"
                    ```
            * 扩展运算符和for...of循环语句会自动忽略通过return语句指定的任何返回值，只要done一变成true就立刻停止读取其他的值。
        * 委托生成器
            * 在某些情况下，我们需要将两个迭代器合二为一，这时可以创建一个生成器，再给yield语句添加一个星号，就可以将生成数据的过程委托给其他生成器
                * 示例代码
                    ```javascript
                        function *createNumberIterator() {
                            yield 1;
                            yield 2;
                        }
                        function *createColorIterator() {
                            yield "red";
                            yield "green";
                        }
                        function *createCombinedIterator() {
                            yield *createNumberIterator();          //此处将createNumberIterator生成器委托给createCombinedIterator生成器
                            yield *createColorIterator();           //此处将createColorIterator生成器委托给createCombinedIterator生成器
                            yield true;
                        }
                        var iterator = createCombinedIterator();
                        console.log(iterator.next()); // "{ value: 1, done: false }"
                        console.log(iterator.next()); // "{ value: 2, done: false }"
                        console.log(iterator.next()); // "{ value: "red", done: false }"
                        console.log(iterator.next()); // "{ value: "green", done: false }"
                        console.log(iterator.next()); // "{ value: true, done: false }"
                        console.log(iterator.next()); // "{ value: undefined, done: true }"
                    ```
            * 利用生成器的返回值来处理复杂任务
                * 示例代码
                    ```javascript
                        function *createNumberIterator() {
                            yield 1;
                            yield 2;
                            return 3;
                        }
                        function *createRepeatingIterator(count) {
                            for (let i=0; i < count; i++) {
                                yield "repeat";
                            }
                        }
                        function *createCombinedIterator() {
                            let result = yield *createNumberIterator();         //此处获取到createNumberIterator生成器return的值3
                            yield *createRepeatingIterator(result);
                        }
                        var iterator = createCombinedIterator();
                        console.log(iterator.next()); // "{ value: 1, done: false }"
                        console.log(iterator.next()); // "{ value: 2, done: false }"
                        console.log(iterator.next()); // "{ value: "repeat", done: false }"
                        console.log(iterator.next()); // "{ value: "repeat", done: false }"
                        console.log(iterator.next()); // "{ value: "repeat", done: false }"
                        console.log(iterator.next()); // "{ value: undefined, done: true }"
                    ```
                * 上述方法，无论通过何种方法调用next()方法，数值3都不会被返回，它只存在于生成器createCombinedIterator的内部，如果想要输出，生成器createCombinedIterator需要这样修改：
                    ```javascript
                        function *createCombinedIterator() {
                            let result = yield *createNumberIterator();         
                            yield result;
                            yield *createRepeatingIterator(result);
                        }
                    ```
            * yield*也可以直接应用于字符串，例如: 
                ```javascript
                yield*"hello"
                ```
                此时将会使用字符串的默认迭代器
    * 异步任务 
        * 由于生成器支持代码暂停（yield）,所以生成器来解决异步问题就有了可行性。
        * 相关案例
            * 简单任务执行器
                * 由于执行yield语句会暂停当前函数的执行过程并等待下一次next()调用
                * 示例代码
                    ```javascript
                        function run(taskDef) {
                            // 创建迭代器，让它在别处可用
                            let task = taskDef();
                            // 启动任务
                            let result = task.next();
                            // 递归使用函数来保持对 next() 的调用
                            function step() {
                                // 如果还有更多要做的
                                if (!result.done) {
                                    result = task.next();
                                    step();
                                }
                            }
                            // 开始处理过程
                            step();
                        }
                        //使用
                        run(function*() {
                            console.log(1);
                            yield;
                            console.log(2);
                            yield;
                            console.log(3);
                        });
                    ```
            * 向任务执行器传递参数
                * 将需要传递的参数通过迭代器的next()方法传入作为yield的生成值使用（next传参是上一次yield的返回值）
                * 示例代码
                    ```javascript
                        function run(taskDef) {
                            // 创建迭代器，让它在别处可用
                            let task = taskDef();
                            // 启动任务
                            let result = task.next();
                            // 递归使用函数来保持对 next() 的调用
                            function step() {
                                // 如果还有更多要做的
                                if (!result.done) {
                                    result = task.next(result.value);
                                    step();
                                }
                            }
                            // 开始处理过程
                            step();
                        }
                        //使用
                        run(function*() {
                            let value = yield 1;
                            console.log(value); // 1
                            value = yield value + 3;
                            console.log(value); // 4
                        });
                    ```
            * 异步任务执行器
                * 示例代码
                    ```javascript
                        //异步任务
                        let fs = require("fs");
                            function readFile(filename) {
                                return function(callback) {
                                    fs.readFile(filename, callback);
                                };
                        }
                        //任务执行器
                        function run(taskDef) {
                            // 创建迭代器，让它在别处可用
                            let task = taskDef();
                            // 启动任务
                            let result = task.next();
                            // 递归使用函数来保持对 next() 的调用
                            function step() {
                                // 如果还有更多要做的
                                if (!result.done) {
                                    if (typeof result.value === "function") {
                                        result.value(function(err, data) {
                                            if (err) {
                                                result = task.throw(err);
                                                return;
                                            }
                                            result = task.next(data);
                                            step();
                                        });
                                    } else {
                                        result = task.next(result.value);
                                        step();
                                    }
                                }
                            }
                            // 开始处理过程
                            step();
                        }
                        //使用
                        run(function*() {
                            let contents = yield readFile("config.json");
                            doSomethingWith(contents);
                            console.log("Done");
                        });

                    ``` 
                * 分析代码
                    * 本例中的异步任务返回的是一个函数，所以我们可以对任务执行器进行修改，当判断迭代器next()返回的value是一个函数时，将函数执行的结果作为参数传给生成器。
        * 随着ES6功能的增加，新出现的async逐渐取代了generator在异步任务上的使用，我们可以将async理解为Generator的语法糖，是一种更简单的写法。
    * 参考网址：https://www.cnblogs.com/xiaohuochai/p/7253466.html
## 2022-02-24
1. ES6中新增的Set与Map
    * Set
        * 允许你存储任何类型的唯一值，无论是原始值或者是对象引用。
        * 特点
            * Set中的元素都是唯一的，不存在重复值（对象的话只要引用地址不同就算两个不同的值）
            * .entries()中key和value是同一个
            * 元素无序
        * 初始化
            * 使用可迭代对象作为传参
                ```javascript
                    let arrSet=new Set([1,2,3])
                    let strSet=new Set("123456")
                    let nodeSet=new Set(document.getElementsByTagName("div"))
                    //...
                ```
            * 初始化后使用add添加元素
                ```javascript
                    let tempSet=new Set();
                    tempSet.add(1);
                    tempSet.add(2).add(3);  //add方法返回的是本身，所以可以使用链式添加
                ```
        * 常见方法和属性
            * add()：添加元素
            * has()：判断有无某个元素
            * delete()：删除某个元素
            * clear()：清空Set集合
            * forEach()：循环
            * size：属性-获取集合长度
        * 遍历方法
            * forEach()
            * for...of
            * 间接使用map与filter
                * 可以使用扩展运算符将Set转换为数组[...set]
                ```javascript
                    let tempSet=new Set();
                    new Set([...tempSet].map(item,index)=>{return item})
                ```
        * 应用场景
            * 数组去重
                ```javascript
                    [...new Set(baseArr)]
                ``` 
    * Map
        * 保存键值对，能够记住键的原始插入顺序。
        * 特点
            * 任何值(对象或原始值)都可以作为一个键或值
            * 查找迅速
            * 一个key只能有一个value，后传入的会将前一个冲掉
        * 初始化
            * 使用二维数组作为传参
                ```javascript
                    let m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
                    m.get('Michael')
                ```
            * 初始化后使用set添加元素
                ```javascript
                    let m = new Map()
                    m.set("Michael",95)
                ```
        * 常用方法和属性
            * set(key,value)：赋值
            * get(key): 取值
            * has(key)：判断Map中是否有某个键值对
            * delete(key)：删除某个键值对
            * forEach()：循环
            * size：属性-Map键值对个数
        * 遍历方法
            * forEach()
            * for...of
    * WeakSet与WeakMap
        * WeakSet
            * 成员都是对象，且成员都是弱引用，可以被垃圾回收机制回收
            * 相关方法：add、delete、has
            * 与Set区别
                * 不能遍历
                * 成员只能是对象，Set是都可以
            * 用法：保存DOM节点，不容易造成内存泄露。
        * WeakMap
            * 特点
                * 不能遍历
                * 只接受对象作为键名（null除外）
                * 键名是弱引用，键值可以是任意，键名所指向的对象可以被垃圾回收，此时键名无效
            * 相关方法：get、set、has、delete
    * 总结：
        * 个人理解Set是对数组的补充，Map是对对象的补充
            * Set相比较数组而言，Set中的值都是唯一的，索引和值都是同一个
            * Map相比较对象而言，Map的key不在局限于字符串或Symbol，Map的key可以是任意值
2. Symbol
    * 定义：表示独一无二的值
    * 初始化：
        * 使用Symbol函数可以生成一个Symbol类型的值，但是你不能再调用Symbol时使用new关键字，因为Symbol是基本数据类型，而不是对象
        * 代码示例：
            ```javascript
                //正确写法
                const a=Symbol();
                const b=Symbol();
                //错误写法
                const a=new Symbol();
            ```
    * 特性
        * 使用Symbol()创建一个Symbol类型的值并赋值给a，那么a在内存中就是一个独一无二的值。除了通过变量a，任何人在任何作用域中都无法重新创建出这个值。
        * 例如上面代码段中的b，也是使用Symbol()创建出来的，但是a!==b
        * 当let c=a时，c可以访问到Symbol()创建的值
        * 个人理解：使用Symbol()就是在内存中创建了一个新对象，赋值语句，相当于将内存地址给了赋值变量
        * 一个Symbol类型的变量只是为了标记一块唯一的内存而存在的。也正是这样，Symbol类型的值不参与运算。
    * 作用
        * 把对象的键名设置为Symbol类型
            * 我们可以有效的避免对象属性被修改，在模块并发中，对象本身更安全
            * Symbol类型数据作为键，该键的内存地址只会被当前作用域的变量s引用，在其他作用域由于无法引用到这里的变量s，也就无法访问对象的这个属性。
            * 代码示例：
                ```javascript
                    let s=Symbol();
                    let obj={
                        name:'hhh',
                        //s是个变量，所以需要用中括号包起来
                        [s]:function(){
                            return this.name
                        }
                    }
                    obj[s]();
                ```
        * 消除魔术字符串
            * 魔术字符串：与代码紧密耦合在一起的某个具体的字符串（或者数字，因为往往难以解释它为什么出现，以及代表什么含义，所以被称为魔术字符串）
            * 对于需要定义一个常量，但是这个常量又仅仅用于判断，不需要知道它具体内容的，可以使用Symbol
            * 代码示例
                ```javascript
                    //原代码
                    function test(shapa){
                        switch(shape){
                            case 'Triangle':        //此处的Triangle就是一个魔术字符串
                                ...
                                break;
                        }
                    }
                    //改进
                    const shapeType={
                        triangle:'Triangle'
                    };
                    function test(shape){
                        case shapeType.triangle:
                            ...
                            break;
                    }
                    test(shapeType.triangle)
                    //使用Symbol改进:此处的shapeType.triangle仅仅是用来判断，没有具体的应用，所以此处可以将triangle设置成Symbol
                    const shapeType={
                        triangle:Symbol()
                    }
                    function test(shape){
                        case shapeType.triangle:
                            ...
                            break;
                    }
                    test(shapeType.triangle)
                ```
    * 语法规范
        * 创建语法：let s=Symbol()
        * 描述符
            * 使用Symbol()创建的变量在控制台中显示的都是Symbol()，为了区分不同的变量，可以在创建Symbol的时候传入一个字符串作为描述
            * 例如：
                ```javascript
                    let s=Symbol('symbol1');
                    let b=Symbol('symbol2');
                ```
            * 需要注意的是，即使使用同一个描述符创建的两个Symbol也并不相等。
            * 如果想要获取到Symbol的描述符，可以借助Symbol原型上的description属性
                ```javascript
                    let s=Symbol('symbol1');
                    console.log(s.description)
                ```
        * 显示转化
            * 转化为字符串：
                * String(s)
                * s.toString()
            * 转化为布尔值：
                * Boolean(s)
        * Symbol属性的遍历
            * 使用Symbol作为对象的属性时，该属性不会再for...in、for...of循环中，也不会出现在Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回
            * 但是该属性不是私有属性，它可以专门被Object.getOwnPropertySymbols()方法遍历出来。
            * 在ES6中新增的Reflect.ownKeys()方法可以遍历出所有的常规键名和Symbol键名
        * Symbol.for()
            * 创建相同Symbol的机制，使用Symbol.for('描述内容')，就会全局注册一个Symbol，下次创建使用Symbol.for（）相同的描述内容就可以创建一个相同的Symbol
            * 代码示例
                ```javascript
                    let s1=Symbol.for('symbol1');
                    let s2=Symbol.for('symbol1');
                    s1==s2      //true
                    Symbol.keyFor(s1)   //"symbol1"
                ```
            * 如果你想获取到一个全局注册的Symbol的描述符，可以使用Symbol.keyFor()方法
    * 内置的Symbol值
        * Symbol.iterator：可迭代对象
        * Symbol.hasInstance：使用instanceof运算符时，实际就是调用改构造函数上的静态方法
        * Symbol.isConcatSpreadable：当前对象作为concat的参数时是否可以展开
        * Symbol.species：继承的时候指定一个类的类别
        * Symbol.match/replace/search/split：自定义String的match/replace/search/split方法
        * Symbol.toPrimitive：定义一个对象如何被转化成一个基本数据类型
        * Symbol.toStringTag：自定义对象的toString方法
        * Symbol.unscopables：用于with语句，指定在使用with语句时，哪些属性不属于with环境
    * 参考网址：https://blog.csdn.net/qq_41694291/article/details/103322409
3. 跨域
    * 同源策略
        * 浏览器不能执行其他网站的脚本。
        * 同源：域名，协议，端口均相同
            * 域名：http://www.baidu.com
            * 协议：http和https
            * 端口：8080端口8081端口
        * 注意：localhost和127.0.0.1虽然都指向本机，但是也是属于跨域
        * 限制以下行为
            * Cookie、LocalStorage和IndexDB无法读取
            * DOM和JS对象无法获得
            * Ajax请求不能发送
    * 解决跨域的方法：
        * JSONP:
        * Cors
        * 代理：vite和vuecli里面的proxy代理
        * Nginx代理
## 2022-02-25
1. Proxy（代理）
    * 主要作用：在访问对象前添加了一层拦截，可以过滤操作
    * 相关语法：
        * 示例代码
            ```javascript
                let p=new Proxy(target,handler);
            ```
        * 参数说明
            * target：需要使用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）
            * handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数（可以理解为触发器）
    * 通常handler中与Reflect中的方法配套使用
        * 实例代码
            ```javascript
                let obj={a:1,b:2};
                let testObj=new Proxy(obj,{
                    get(target,property){
                        console.log("获取对象的属性",property)
                        return Reflect.get(target,property)
                    },
                    set(target,property,value){
                        console.log("设置对象的属性",property,value)
                        return Reflect.set(target,property,value)
                    }
                })
            ```
    * 实际应用
        * 在Vue3中使用Proxy()实现数据代理，在Vue2中使用Object.defineProperty()
2. Reflect（反射）   
    * ES6为了操作对象而新增的API 
    * Reflect不是构造函数，使用的时候直接通过Reflect.method()调用，不要使用new
    * 新增原因
        * 更加有用的返回值
            * Reflect有一些方法与ES5中Object方法一样，比如Reflect.getOwnPropertyDescriptor和Reflect.defineProperty, 在Object中如果执行失败，会抛出错误，需要try-catch捕获，而Reflect返回的是true和false
        * 函数操作
            * 如果要判断一个obj有定义或者继承了属性name，在ES5中这样判断：name in obj；或者删除一个属性：delete obj[name]，虽然这些很好用，很简短，很明确，但是要使用的时候也要封装成一个类
            * 有了Reflect，直接帮你封装好了，Reflect.has(obj,name),Reflect.deleteProperty(obj,name) 
        * 更加可靠的函数执行方式
            * 某些函数可能被对象重新构造了，例如apply，要使用原始的方法Function.prototype.apply.call(f,obj,args)，但是使用Reflect就可以直接Reflect.apply(f,obj,args)
        * 可变参数形式的构造函数
            * 通过不定长度的参数实例化一个构造函数，可以直接使用Reflect.construct(F,args)
        * 控制访问器或者读取器的this
            * Reflect.get与set方法有一个额外的参数，允许我们设置setter和getter的上下this
        * 避免直接访问__proto__
            * Reflect.getPrototypeOf(obj)和Reflect.setPrototypeOf(obj,newProto)
    * 常用方法
        * Reflect.apply
            * Function.prototype.apply()的替身
            * 参数
                * 第一个：需要执行的函数
                * 第二个：需要执行函数的上下文this
                * 第三个：一个数组或者伪数组，作为执行函数的参数
        * Reflect.construct
            * 实例化构造函数
            * 参数
                * 第一个：构造函数
                * 第二个：由参数组成的数组或者伪数组
                * 第三个（可选）：超类，新元素会继承这个超类
        * Reflect.defineProperty
            * 通过直接赋值的方式把属性和属性值赋给对象
            * 参数
                * 第一个：对象
                * 第二个：属性名
                * 第三个：属性值
            * 返回值：boolean
        * Reflect.deleteProperty
            * 删除对象的属性
            * 参数
                * 第一个：对象
                * 第二个：属性名
            * 返回值：boolean
        * Reflect.get
            * getter读取器
            * 参数
                * 第一个：目标对象
                * 第二个：属性名
                * 第三个（可选）：读取器的上下文(this)
        * Reflect.set
            * setter
                * 第一个：目标对象
                * 第二个：属性名
                * 第三个：属性值
3. 关于css隐藏元素的方法
    * 方法
        * display:none;
        * visibility:hidden;
        * opacity:0;
    * 区别
        * 占据空间：display:none;不占据空间，其他两个仍然占据空间
        * 回流与重绘：display会引起页面的回流与重绘，其他两个不会
        * 子代继承：display不会被子代继承，但是其他两个会
        * transition：display无效，但是其他两个有效
        * 绑定的事件：只有opacity会响应，其他两个不会响应
4. 适配移动端方案
    * 利用meta标签对viewport进行控制
        * 代码示例
            ```html
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
            ```
        * 参数解析
            width：设置layout viewport的宽度，为一个正整数，或者字符串"width-device"
            initial-scale：设置页面的初始缩放值
            maximum-scale：允许用户的最大缩放值
            minimum-scale：允许用户的最小缩放值
            user-scalable：是否允许用户进行缩放，值为no或yes
    * 选择方案
        * 媒体布局+rem
            * 原理
                * 基于css媒体查询属性@media分别为不同屏幕尺寸的移动设备编写不同尺寸的css属性
                * 不同的屏幕尺寸设置不同的html下的font-size
                * 使用rem
            * 示例代码
                ```css
                    @media only screen and (min-width: 375px) {
                        html {
                            font-size : 375px;
                        }
                    }

                    @media only screen and (min-width: 360px) {
                        html {
                            font-size : 360px;
                        }
                    }

                    @media only screen and (min-width: 320px) {
                        html {
                            font-size : 320px;
                        }
                    }
                ```
            * 缺点
                * 不同的尺寸需要写多个@media
                * 所有涉及到使用rem的地方，全部需要调用方法calc()
        * flexable+rem
            * 原理
                * 在rem方案上面进行改进，可以使用js动态设置根字体
                * 典型代表：lib-flexible
            * 实现过程
                * 使用rem模拟vw适配多种屏幕（将html节点的font-size设置成页面布局视口的1/10,之后使用rem相当于使用页面宽度）
                    * 核心代码
                        ```javascript
                            function setRemUnit () {
                                var rem = docEl.clientWidth / 10
                                docEl.style.fontSize = rem + 'px'
                            }
                            setRemUnit();
                        ```
                * 控制viewport的width和scale值适配高倍屏显示
                    * 设置viewport的width为device-width，改变浏览器viewport（布局视口和视觉视口）默认宽度为理想视口宽度，从而使用户可以在理想视口内看到完整的布局视口的内容。
                    * 等比设置viewport的initial-scale、maximum-scale、minimum-scale的值，从而实现1物理像素=1css像素，以适配高倍屏的显示效果
                    * 核心代码
                         ```javascript
                            var metaEL= doc.querySelector('meta[name="viewport"]');
                            var dpr = window.devicePixelRatio;
                            var scale = 1 / dpr
                            metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); 
                        ```
            * 缺点
                * 由于其缩放的缘故，video标签的视频播放器的样式在不同dpr的设备上展示差异很大。
                * 对于安卓手机而言，lib-flexible一律按dpr=1处理
                * 不再兼容@media的响应式布局，因为@media语法中涉及到尺寸的查询，查询的尺寸依据是当前设备的物理像素，与flexible的布局（即针对不同 dpr 设备等比缩放视口的 scale 值，从而同时改变布局视口和视觉视口大小）相悖
        * vw方案
            * 即使用vw,vh,vmax,vmin等取代px
            * px转vw插件：postcss-px-to-viewport
                * 标注不需要转换的属性：在项目中，如果某一场景下不需要将px转化成vw，那么可以使用如下方法
                    * /* px-to-viewport-ignore-next */ —> 下一行不进行转换
                    * /* px-to-viewport-ignore */ —> 当前行不进行转换
                    * 代码示例：
                        ```css
                            /* 转换前: */
                            .class {
                                /* px-to-viewport-ignore-next */
                                width: 10px;
                                padding: 10px;
                                height: 10px; /* px-to-viewport-ignore */
                            }
                            /* 转换后: */
                            .class {
                                width: 10px; 
                                padding: 3.125vw;
                                height: 10px;
                            }
                        ```
    * 参考网址：https://juejin.cn/post/7046169975706353701
## 2022-04-06
1. 三次握手与四次挥手
    * TCP与UDP
        * UPD：用户数据报协议
            * 特点
                * 在传送数据之前不需要先建立连接
                * 不提供可靠交付
            * 一般用于即时通信，比如：QQ语音、QQ视频、直播
        * TCP：传输控制协议
            * 特点： 
                * 面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接
                * 不提供广播或多播服务
                * 提供可靠的，面向连接的传输服务（可靠体现在三次握手和四次挥手来建立连接和断开连接）
            * 一般用于文件传输、发送和接收邮件、远程登录等场景
    * TCP报文段首部格式（详见参考网址）
        * 序号ISN（seq）
        * 确认号（ack）
        * 确认ACK
            * 仅当 ACK=1 时确认号字段才有效，当 ACK=0 时确认号无效。
            * TCP规定，在连接建立后所有传送的报文段都必须将ACK置为1
        * 同步SYN
            * SYN=1 表示这是一个请求或者连接接受报文。
            * 当 SYN=1 而 ACK=0 时，表示这是一个连接请求报文段，若对方同意建立连接，则应在响应的报文段中使 SYN=1 且 ACK=1
        * 终止FIN
            * 用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已经发送完毕，并要求释放运输连接。
    * 三次握手建立连接
        * 主要作用：确认双方的接收能力和发送能力是否正常、指定自己的初始化序号为后面的可靠性传输做准备
        * 相关状态介绍：
            * Closed:没有任何连接状态
            * Listen:侦听来自远方TCP端口的连接请求
            * SYN_SENT:在发送连接请求后等待匹配的连接请求
            * SYN_RECEIVED:在收到和发送一个连接请求后等待对连接请求的确认
            * Establised：代表一个打开的连接，数据可以传送给用户
        * 过程：
            * 刚开始客户端处于Closed状态，服务端处于Listen状态
            * 第一次握手：
                * 客户端向服务端发送一个 SYN=1 的报文，并指定初始化序列号 seq=x ,表示本报文段所发送数据的第一个字节的序号。此时客户端处于SYN_SENT状态
                * SYN=1; seq=x
            * 第二次握手：
                * 服务器接收到客户端的SYN报文之后，会发送 SYN=1 的报文作为应答，并且指定自己的初始序列号 seq=y 。同时将客户端发来的 x+1 作为自己的确认号的值（ack=x+1）,表示希望收到的下一个数据的第一个字节的序号是 x+1 ，此时 ACK=1 表示确认号有效。此时服务器处于SYN_RECEIVED的状态
                * SYN=1; seq=y; ACK=1; ack=x+1
            * 第三次握手：
                * 客户端收到服务器的响应SYN报文之后，会发送一个ACK报文，将服务器返回来的 y+1 作为确认号ack的值，ACK=1 , ack=y+1，同时将 seq=x+1 作为序号传给服务端。此时客户端处于Establised状态，服务器接收到ACK报文之后，也处于Establised状态，至此，客户端与服务端建立TCP连接
                * seq=x+1; ACK=1; ack=y+1
        * 相关问题
            * 三次握手的目的
                * 双方确认自己与对方的发送与接收是正常的
            * ISN是固定的吗
                * 如果ISN是固定的，攻击者很容易猜出后续的确认号，所以ISN是动态生成的
            * 三次握手可以携带数据吗
                * 第三次握手的时候，是可以携带数据的，第一次和第二次不可以
                * 第三次，客户端已经知道自己的接收，发送，服务器的接收，发送能力是好的，所以可以直接发送数据了
                * 简单记忆： SYN=1 的时候不可以携带数据
                * 原因：如果第一次和第二次可以携带数据的话，那么可以在SYN报文中恶意发送大量数据，导致服务器花费大量时间，内存空间来接收这些报文（恶意发送不需要考虑服务器的接收发送能力）
            * 如果第三次握手丢失了，客户端和服务端会怎么处理
                * 服务端：服务端会进行首次重传，等待一段时间仍未收到客户端确认包，就进行二次重传。如果重传超过系统规定的最大重传次数，则系统将该连接消息从半连接队列中删除。
                * 注意：每次重传的时间不一定相等，一般会指数增长，例如1s、2s、4s、8s...
    * 四次挥手断开连接
        * 主要作用： 终止一个TCP连接，客户端和服务端均可以主动发起挥手动作
        * 相关状态介绍：
            * FIN_WAIT_1:等待远程TCP的连接中断请求，或先前的连接中断请求的确认
            * CLOSE_WAIT:等待从本地用户发来的连接中断请求
            * FIN_WAIT_2:从远程TCP等待连接中断请求
            * LAST_ACK:等待原来发向远程TCP的连接中断请求的确认
            * TIME_WAIT:等待足够的时间以确保远程TCP接收到连接中断请求的确认
        * 过程：
            * 刚开始客户端和服务端处于Establised状态，此处我们假设是客户端发起挥手动作
            * 第一次挥手
                * 客户端发送一个FIN报文 FIN=1 ,报文中指定一个序列号 seq=u 。并停止再发送数据，主动关闭TCP连接。此时客户端处于FIN_WAIT_1状态，等待服务端确认
                * FIN=1; seq=u
            * 第二次挥手
                * 服务端接收到FIN报文之后，会发送ACK报文，且把客户端的序号值+1作为自己的确认号，表示已经接收到客户端的报文了，此时服务端处于CLOSE_WAIT状态
                * ACK=1; ack=u+1; seq=v
                * 注：此时TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT_2状态，等待服务端发出的连接释放报文
            * 第三次挥手
                * 如果服务端没有要向客户端发出的数据了，此时服务端也发送FIN报文，且指定一个序列号。此时服务端处于LAST_ACK状态，等待客户端确认
                * FIN=1; seq=w; ACK=1; ack=u+1
            * 第四次挥手
                * 客户端收到FIN之后，发送一个ACK报文作为应答，且把服务端的序列值+1作为自己的确认号，此时客户端处于TIME_WAIT状态
                * ACK=1; ack=w+1; seq=u+1
                * 注意：
                    * 这个时候由服务端到客户端的TCP连接并没有释放掉，需要经过时间等待计时器设置的2MSL（一个报文的来回时间）后才会进入Closed状态
                    * 目的：确保服务端收到自己的ACK报文。如果服务端在规定时间内没有收到客户端发来的ACK报文，服务端会重新发送FIN报文给客户端，客户端收到FIN报文之后，再次发送ACK报文给服务端
                    * 服务端收到ACK报文之后，就关闭连接，处于Closed状态。
        * 相关问题
            * 为什么要四次挥手
                * 由于TCP的半关闭特性，TCP提供了连接的一端在结束它的发送之后还能接收来自另一端的数据的能力
                * 通俗来讲：两次挥手可以释放一端到另一端的TCP连接，想要完全释放一共需要四次
    * 参考网址：https://baijiahao.baidu.com/s?id=1693383134922615393&wfr=spider&for=pc
2. 从浏览器地址输入url到请求返回发生了什么
    * URL解析
        * 判断你输入的是一个合法的URL还是一个待搜索的关键字，并且根据输入的内容进行自动完成字符编码等操作
    * URL地址转化为IP地址
        * 查找缓存：
            * 根据URL检查浏览器缓存，看之前有没有访问过这个URL的IP
            * 如果没有，检查操作系统的DNS缓存
            * 如果没有，检查路由器的DNS缓存
            * 如果没有，查找ISP DNS(在客户端电脑上设置的首选DNS服务器)缓存
            * 如果仍然没有，进入下一步，DNS域名解析
        * DNS域名解析
            * 浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。
            * DNS服务器是基于UDP的，因此会用到UDP协议。
    * 请求服务器
        * 建立TCP连接
            * 使用三次握手创建TCP连接
        * 发起HTTP请求
            * 浏览器发起读取文件的HTTP请求
        * 服务器响应并返回结果
            * 服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器
        * 关闭TCP连接
            * 使用四次挥手断开TCP连接
    * 浏览器渲染
        * 渲染页面
            * 构建DOM树：处理HTML标记并构建DOM树，处理CSS标记并构建CSSOM树
            * 构建渲染树：将DOM和CSSOM树合并，构成渲染树
            * 布局渲染树：计算每个节点的大小和位置信息(回流)
            * 绘制渲染树：将渲染树的每个节点换成屏幕的实际像素(重绘)
        * JS引擎解析
            * 过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO,作用域链，回收机制等等）
                * 创建window对象
                    * window对象也叫全局执行环境，当页面产生时就被创建，所有的全局变量和函数都属于window的属性和方法
                    * DOM树也会映射到window的document对象上
                    * 当关闭网页或者关闭浏览器时，全局执行环境（window）会被销毁
                * 加载文件
                    * 完成js引擎分析它的语法和词法是否合法，如果合法进入预编译
                * 预编译
                    * 在预编译过程中，浏览器会寻找全局变量声明，并将其作为属性添加至window对象中，并给变量赋值为undefined
                    * 寻找全局函数声明，将其作为方法添加至window对象中，并将函数体赋值给它
                    * 注意
                        * 匿名函数时不参与预编译的，因为它是变量
                        * 在ES6中，变量提升被解决了，但是函数提升还存在
                * 解释执行
                    * ES5中，变量如果没有预编译就直接赋值，那么在非严格模式下会把这个变量变成window的一个属性
                    * string，int这类值会直接把值放在变量的存储空间中，object对象则时把指针指向变量的存储空间
                    * 函数执行，就是把函数的环境推入一个环境的栈中，执行完成后再弹出，控制权交还给之前的环境
                    * JS作用域其实就是这样的执行流机制实现的
## 2022-06-06
1. with
    * 作用
        * 方便用来引用某个对象中已有的属性
        * 简单来讲：with就相当于一种速写方式，在指定的代码区域，通过节点名称就能调用对象
    * 注意点
        * 只能使用对象中已有的属性，不能给使用的对象添加属性(引用对象特殊，需要考虑一下)
        * 使用的属性，必须是对象中有的
        * 使用with关联对象后，如果内部局部变量和with关联的对象属性重名时，内部局部变量会指向关联对象里面的属性
    * 代码示例
        * 简单示例
            ```javascript
                let baseObj = {
                    test1: '111',
                    test2: '222',
                    test3: {
                        a: 1,
                        b: 2
                    }
                }
                with(baseObj){
                   let a = test1
                   let b = test2
                   let c = test3
                   test1 = 2        // 赋值失败
                   test3.a = '2'    // 赋值成功
                }
            ```
        * 实用案例
            ```javascript
                // 普通写法
                x = Math.cos(3 * Math.PI) + Math.sin(Math.LN10)
                y = Math.tan(14 * Math.E)
                // 使用with简写’
                with(Math){
                    x = cos(3 * PI) + sin(LN10)
                    y = tan(14 * E)
                }
            ```
    * 缺点
        * with会自动在全局作用域中创建一个全局变量，在严格模式下，会抛出ReferenceError异常。with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。
        * with在相同条件下比不使用它慢了很多，具体的原因是js在运行之前的预编译时，如果在代码中发现with,只能简单的假设关于标识符的位置都是无效的，无法知道传递给with用来创建新词法作用域的对象的内容到底是什么，所以js不会优化。
## 2022-07-07
1. structuredClone
    * 原生的实现js深拷贝的方法，但是目前只兼容较高版本的浏览器
    * 代码示例
        ```javascript
        let baseObj = { a: 1, b: 2 }
        let testObj = structuredClone(baseObj)
        ```
## 2022-08-09
1. 如何使用meta标签
    * 介绍
        * <meta>元素用来表示不能由其他HTML元相关元素表示的数据，元素标签内不包含任何内容
        * 具有不同属性的多个<meta>元素可以在同一个页面上使用
        * <meta>元素内容不会显示在页面上，但是对于机器而言是可读的，可用于模拟HTTP响应头字段的使用
        * <meta>标签通常位于<head>区域内，但是在HTML5中不再需要<head>标签
    * 属性
        * 属性图表
            |属性|值|描述|
            | --- | --- | --- |
            |charset|character_set|规定HTML文档的字符编码|
            |content|text|定义与http-equiv或name属性相关的元信息|
            |http-equiv|content-security-policy<br>content-type<br>default-style<br>refresh<br>...|把content属性关联到HTTP头部|
            |name|application-name<br>author<br>description<br>generator<br>keyworks<br>viewport<br>...|把content属性关联到一个名称|
            |scheme|format/URI|定义用于翻译content属性值的格式|
        * 属性详解
            * name
                * 提供了名称/值 对中的名称。
                * 通常情况下，可以使用对自己和原文档读者来说具有意义的名称
                * 例如：
                    * keyword常用来表示文档的关键字
                    * author表示作者
                * 如果没有提供name属性，那么名称/值中的名称会去http-equiv属性的值
            * http-equiv
                * 提供了名称/值 对中的名称
                * 指示服务器在发送实际文档之前先要传送给浏览器的MIME文档头部包含的名称/值对
                * 服务器向浏览器发送文档时，会先发送许多名称/值对。但是，content-type: text/html必须要发送，这将告诉浏览器准备接收一个HTML文档
                * 例如：
                    * html中定义的meta
                        ```html
                        <meta http-equiv="expires" content="31 Dec 2008">
                        ```
                    * 发送到浏览器的头部
                        ```
                        content-type: text
                        charset: iso-8859-1
                        expires: 31 Dec 2008
                        ```
            * content
                * content属性提供了名称/值对中的值
                * 该值可以是任何有效的字符串
                * content属性始终要和name属性和http-equiv属性一起使用
            * scheme
                * 定义了content属性中值的格式
                * 例如：
                    ```html
                    <head>
                        <meta name="date" content="2009-01-01" scheme="YYYY-MM-DD">
                        <meta name="identifier" content="0-2345-6634-6" scheme="ISBN">
                    </head>
                    ```
            * charset
                * HTML5中新增的属性
                * HTML4和HTML5中写法区别
                    * HTML4:
                        ```html
                        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
                        ```
                    * HTML5:
                        ```html
                        <meta charset="UTF-8">
                        ```
    * 常用案例
        ```html
        <!-- 定义创作者和修改信息 -->
        <meta name="author" content="Chris Mills">
        <meta name="revised" content="David Yang 8/1/07">
        <!-- 定义文档关键词和页面描述，用于搜索引擎 -->
        <meta name="keywords" content="HTML,CSS,XML">
        <meta name="description" content="test HTML">
        <!-- 在文档级别上设置浅色和深色工作方式 -->
        <meta name="color-scheme" content="dark light">
        <!-- 定义搜索引擎机器人(不包括恶意爬虫)对此页面的处理行为,详细配置可参考网址 -->
        <meta name="robots" content="index,follow">
        <!-- 典型的移动优化网站会设置 <meta> 标签视口宽度等于屏幕宽度，这样可以避免当视口宽度大于屏幕宽度时，出现横向滚动条,详细配置可参考网址 -->
        <meta name="viewport" content="width=device-width, initial-scale=1">


        <!-- 演示3秒后，重定向到另外一个地址，如果url为空则会刷新当前页面 -->
        <meta http-equiv="refresh" content="3;url=https://www.baidu.com">
        <!-- 为当前页面定义内容策略，例如，已经存在的一个网站，用了太多内联代码修复问题，而且想确保资源（如图片、字体、脚本等）只从 https 加载，并且禁止插件 -->
        <meta http-equiv="Content-Security-Policy" content="default-src https: 'unsafe-eval' 'unsafe-inline'; object-src 'none'">
        <!-- 微前端需要按功能拆分多个子应用，主应用在加载的过程中经常出现加载失败的问题。因为 https 地址中，如果加载了 http 资源，浏览器将认为这是不安全的资源，将会默认阻止。后来在文档中添加了以下 <meta> 标签完美解决 -->
        <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
        <!-- 禁止浏览器从本地机的缓存中调阅页面内容，设定后，一旦离开网页就无法从 Cache 中再调出 -->
        <meta http-equiv="Pragma" content="no-cache">
        ```
    * 参考网址：https://juejin.cn/post/7128694683709997093
2. IntersectionObserver（监听元素是否进入视口”viewport“）
    * 介绍
        * 在网页开发时，经常需要判断一个元素是否进入视口，即用户能不能看到它
        * 传统的做法时监听scroll事件，调用元素的getBoundingClientRect()方法获取元素相对于视口的坐标，从而判断是否在视口内， 但是该方法需要频繁调用scroll事件，会造成性能问题
        * 使用IntersectionObserver对象可以有效的避免频繁调用scroll事件
    * 用法
        * 代码示例
            ```javascript
            // 构造函数创建对象
            let observer = new IntersectionObserver(callback, options)
            // 开始观察
            observer.observe(target)
            // 停止观察
            observer.unobserve(target)
            // 关闭观察器
            observer.disconnect()
            ```
        * 相关参数介绍
            * IntersectionObserver: 浏览器原生提供的构造函数，接收两个参数
                * callback: 可见性变化时的回调函数
                * options: 配置对象（可选）
            * target: 观察的Dom节点
            * 注：IntersectionObserver API是异步的，不随目标的滚动同步触发，只有线程空闲下来，才会执行观察器。意味着，这个观察器的优先级非常低，只有在其他任务执行完，浏览器有了空闲才会执行
        * 实例
            ```javascript
            let observer = new IntersectionObserver(
                (entries, observer) => {
                    // 执行回调的事件
                }, {
                    // 监听方式一：相对视口可见性
                    // 元素进入视口（或者容器元素）多少比例时，执行回调函数
                    threshold: [0, 0.25, 0.5, 0.75, 1],  
                    // 监听方式二：相对所在容器可见性
                    // root属性指定目标元素所在的容器节点。
                    // 注意，容器元素必须是目标元素的祖先节点。
                    root: document.querySelector('.container'),
                    rootMargin: '0px 0px -200px 0px'
                }
            )
            ```
    * 参考网址：https://www.bookstack.cn/read/webapi-tutorial/docs-intersectionObserver.md
3. Intl对象
    * Intl对象是ECMAScript国际化API的命名空间，它提供了精确的字符串对比、数字格式化，和日期时间格式化。
    * 相关对象
        * Intl.Collator：排序器构造函数，支持对语言敏感的字符串比较
        * Intl.DateTimeFormat：根据语言来格式化日期和时间的对象的构造器
        * Intl.ListFormat：是一个语言相关的列表格式化构造器
        * Intl.NumberFormat：是对语言敏感的格式化数字类的构造器类
        * Intl.PluralRules：对象是用于启用多种敏感格式和多种语言规则的构造函数
        * Intl.RelativeTimeFormat：对象启用本地化的相对时间格式
        * Intl.Segmenter：考虑到语言环境，将字符串分解为字素、单词和句子
    * 相关方法
        * getCanonicalLocales(locales)
            * 返回一个数组，数组包含规范的区域语言代码
                ```javascript
                Intl.getCanonicalLocales('EN-US')  // 返回['en-US']
                ```
    * 参考网址：
        * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl
        * https://zhuanlan.zhihu.com/p/497449590
## 2022-08-10
1. Date对象中toISOString方法
    * 使用 ISO 标准返回 Date 对象的字符串格式
        ```javascript
        new Date().toISOString() //'2022-08-10T01:44:57.678Z'
        new Date(+new Date()+8*3600*1000).toISOString() // '2022-08-10T09:45:24.680Z'
        ```
    * 用途：可快速获取yyyy-mm-dd格式的日期字符串
    * 缺点：使用ISO转换的时间会转换成ISO标准，也就是说会比实际时间（东八区）少8个小时，所以需要加上。
2. XSS攻击
    * 介绍
        * XSS攻击全称跨站脚本攻击（Cross Site Scripting）
        * XSS是一种在Web应用中的计算机安全漏洞，它允许恶意Web用户将代码植入到提供给其他用户使用的页面中。
        * XSS本质是在于执行脚本（javascript/html等）
        * 总结：XSS就是拼接恶意的HTML
    * 危害
        * 盗取用户Cookie
        * DOS（拒绝服务）客户端浏览器
        * 钓鱼攻击，高级的钓鱼技巧
        * 删除目标文章，恶意篡改数据、嫁祸
        * 劫持用户Web行为，甚至进一步渗透内网
        * 爆发Web2.0蠕虫
        * 蠕虫式的DDOS攻击
        * 蠕虫式挂马攻击、刷广告、刷流量、破坏网上数据
        * 其他安全问题
    * 分类
        * 反射型XSS
            * 你提交的恶意数据成功的实现了XSS，但是仅仅是对你这次访问产生了影响，是非持久型攻击
            * 攻击步骤
                * 攻击者构造出特殊的URL，其中包含恶意代码
                * 用户打开带有恶意代码的URL，网站服务器将恶意代码从URL中取走，拼接在HTML中返回给浏览器。
                * 用户浏览器接收响应后解析执行，混在其中的恶意代码也被执行
                * 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
        * 存储型XSS
            * 你提交的数据成功的实现了XSS，存入了数据库或者写入日志，别人访问这个页面的时候就会自动触发
            * 攻击步骤
                * 攻击者将恶意代码提交到目标网站的数据库中
                * 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTML中返回给浏览器
                * 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
                * 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。
            * 注：存储型XSS和反射型XSS的差别在于，存储型XSS提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码
            * 典型的例子就是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，留言的内容会从数据库中被取出来，浏览器将存储的XSS代码当作正常HTML和JS执行。
        * DOM型XSS
            * 攻击步骤
                * 攻击者构造出特殊的 URL，其中包含恶意代码。
                * 用户打开带有恶意代码的 URL。
                * 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
                * 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
            * 注：DOM型XSS和其他两类XSS攻击的区别在于：DOM型XSS攻击中，取出和执行恶意代码都是由浏览器端完成的，不涉及服务端，属于前端javascript自身的安全漏洞。
    * 常见案例
        ```html
        <!-- 最普通的XSS -->
        <script>alert('XSS')</script>
        <!-- 获取cookie -->
        <script>alert(document.cookie)</script>
        <!-- img链接地址xss -->
        <img src="javascript:alert('XSS')">
        <!-- 外部攻击代码 -->
        <script src='ls.js'></script>
        <!-- 注释方法防止过滤 -->
        <script>alert/*注释*/('XSS')</script>
        <!-- 加载图像失败执行 -->
        <img src='' οnerrοr="alert('XSS')">
        <!-- 框架 -->
        <iframe onload="alert('XSS')">
        <!-- 跳转某页面 -->
        <script>location='baidu.com';</script>
        <!-- a链接的xss -->
        <a href="javascript:alert('XSS')"></a>
        <!-- 在css样式中加入 -->
        <style>
            body{ background-image:url(javascript:alert('XSS')) } 
        </style>
        ```
    * 防御方法
        * 转义HTML
        * 纯前端渲染
        * 预防DOM型XSS攻击
        * 输入内容长度控制
    * 参考网址：
        * https://blog.csdn.net/weixin_38984030/article/details/93494600?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-93494600-blog-123028852.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-93494600-blog-123028852.pc_relevant_default&utm_relevant_index=2
        * https://blog.csdn.net/m0_55854679/article/details/123028852
3. 浏览器缓存
    * 介绍
        * 浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。
        * 优点
            * 减少冗余的数据传输
            * 减少服务器负担
            * 加快客户端加载网页的速度
    * 分类
        * 强缓存（本地缓存）
            * 当请求资源时，如果是之前请求过的，那么在过期时间内将不会发送本次请求向服务器获取资源，而是直接从浏览器缓存中获取（不管资源是否改动）。过期了将重新从服务器获取，并再次强缓存。
            * 实现方式
                * 强缓存主要是利用http头中的Expires或Cache-Control两个字段来控制
                * Expires是http1.0规范；Cache-Control是http1.1规范，我们这里使用Cache-Control规范
                * Cache-Control常用值
                    * private：仅浏览器可以缓存（默认）
                    * public：浏览器和代理服务器都可以缓存
                    * max-age=xxx：过期时间（单位秒）
                    * no-cache：不进行强缓存
                    * no-store：不强缓存，也不协商缓存
        * 弱缓存（协商缓存）
            * 当请求资源时，如果是之前请求过的，那么还是发送请求到服务器，服务器通过逻辑判断确认资源是否修改，如果没有修改，那么返回304状态码，资源直接从缓存中获取；如果是修改过的，那么将资源重新发送到客户端，并且客户端更新缓存。
            * 判断资源是否修改有两种标准
                * 判断最后修改时间是否变了
                * 判断资源的内容是否修改
            * 实现方式
                * 弱缓存主要涉及到两组header字段：Etag和If-None-Match、Last-Modified和if-modified-since
                * Etag和If-None-Match实现方式（对应判断资源内容是否修改）
                    * Etag中存放一个校验码，资源的变化会导致Etag的变化
                    * If-None-Match在每一次请求的时候的时候将Etag的值传给服务器，服务器根据If-None-Match的值来判断是否命中
                    * 如果命中，则返回304,同时将Etag返回（即使这个Etag和原来的一样）；如果没有命中，则返回资源和新的Etag
                * Last-Modified和if-modified-since实现方式（对应判断最后修改时间）
                    * 浏览器第一次请求一个资源时，服务器会返回一个Last-Modified，用来标识资源的最后修改时间
                    * 当浏览器再次请求资源时，if-modified-since会将Last-Modified的值传给服务器，服务器根据资源的最后修改时间判断是否命中
                    * 如果命中，则返回304，并且不会返回资源内容，也不会返回Last-Modified；如果没有命中，则返回资源和新的Last-Modified
    * 参考网址：https://juejin.cn/post/7083178636852854792
4. SSE（Server-Sent Events）
    * 介绍
        * 一种服务端向客户端推送数据的方案
        * 实现原理
            * 一般来说，HTTP 协议只能客户端向服务器发起请求，服务器不能主动向客户端推送。但是有一种特殊情况，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。
            * SSE就是利用这种机制，使用流信息向浏览器推送信息
            * 基于HTTP协议，除了IE/Edge,其他浏览器都支持
        * 与WebSocket对比
            * SSE和WebSocket作用相似，都是建立浏览器和服务器之间的通信渠道，然后服务器向浏览器推送消息
            * WebSocket更强大和灵活。因为它是全双工通道，可以双向通信，而SSE是单向通道，只能服务器向浏览器发送（SSE的本质是下载）
        * 优点
            * SSE使用HTTP协议，现有的服务器软件都支持；WebSocket是一个独立协议
            * SSE属于轻量级，使用简单；WebSocket协议相对复杂
            * SSE默认支持断线重连；WebSocket需要自己实现断线重连
            * SSE一般只用来传送文本，二进制数据需要编码后传送；WebSocket默认支持传送二进制数据
            * SSE支持自定义发送的消息类型
    * 实现方式
        * 详见参考网址
    * 参考网址：https://www.bookstack.cn/read/webapi-tutorial/docs-server-sent-events.md
## 2022-08-11
1. H5语义化
    * HTML语义化是指：合理正确的使用语义化的标签来创建页面结构，即正确的标签做正确的事
    * 常用的语义化标签：<header><nav><main><article><aside><footer><section>
    * 语义化的优点
        * 在没有CSS样式的情况下，页面整体也会呈现很好的结构效果
        * 代码结构清晰，易于阅读
        * 利于开发维护，方便其他设备解析（如屏幕阅读器）根据语义渲染网页
        * 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重
## 2022-08-23
1. Grid布局
    * 简介
        * Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别
        * Flex 布局是轴线布局，只能指定"项目"针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成"行"和"列"，产生单元格，然后指定"项目所在"的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。
    * 相关概念
        * 容器与项目：采用网格布局的区域，称为容器。容器内部采用网格定位的子元素，称为项目。
        * 行和列：容器的水平区域称为行row，垂直区域称为列column
        * 单元格：行和列的交叉区域，称为单元格cell，通常m行n列会产生m*n个单元格
        * 网格线：划分网格的线，称为网格线，水平网格线划分出行，垂直网格线划分出列，通常n行有n+1根水平网格线，m列有m+1根垂直网格线
    * 容器属性
        * display: grid
            * 指定一个容器采用网格布局
            * 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。
        * grid-template-columns、grid-template-rows
            * grid-template-columns属性定义每一列的列宽
            * grid-template-rows属性定义每一行的行高
            * 关键字
                * repeat(): 重复同样的值
                * auto-fill: 自动填充，会容纳尽可能多的单元格
                * fr: fraction缩写，方便表示比例关系
                * minmax(): 产生一个长度范围，表示长度就在这个范围之中，接收两个参数，分别是最大值和最小值
                * auto：表示由浏览器自己决定长度
            * 网格线名称：使用方括号，指定每一根网格线的名字，方便以后的引用
            * 使用百分比可以方便的实现各单元格占比
        * grid-row-gap、grid-column-gap、grid-gap
            * grid-row-gap属性设置行与行之间的间隔
            * grid-column-gap属性设置列与列之间的间隔
            * grid-gap属性是grid-row-gap和grid-column-gap的合并简写形式
                * 如果省略第二个值表示第二个值和第一个值一样
            * 最新标准中属性名称省略了grid，即：row-gap、column-gap、gap
        * grid-template-areas
            * 网格布局允许指定区域，一个区域由单个或多个单元格组成，grid-template-areas属性用于定义区域
            * 案例
                ```css
                .container {
                    display: grid;
                    grid-template-columns: 100px 100px 100px;
                    grid-template-rows: 100px 100px 100px;
                    grid-template-areas: 'a a a'
                                         'b b d'
                                         'c c c';
                }
                ```
                * 以上案例将容器分为a、b、c、d四个区域
            * 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。
        * grid-auto-flow
            * grid-auto-flow属性定义了容器中项目的自动放置顺序
            * 属性值：
                * row：先行后列
                * column：先列后行
                * row-dense: 先行后列，并且尽可能紧密填满，不留出空格
                * column-dense: 先列后行，并且尽可能紧密填满，不留出空格
        * justify-items、align-items、place-items
            * justify-items属性设置单元格内容的水平位置（左中右）
            * align-items属性设置单元格内容的垂直位置（上中下）
            * place-items属性是align-items属性和justify-items属性的合并简写形式，如果省略第二个参数表示第二个参数和第一个参数一样
            * 属性值
                * start: 对齐单元格的起始边缘
                * end: 对齐单元格的结束边缘
                * center: 单元格内部居中
                * stretch: 拉伸，占满单元格的整个宽度（默认值）
        * justify-content、align-content、place-content
            * justify-content属性是整个内容区域在容器里面的水平位置（左中右）
            * align-content属性是整个内容区域的垂直位置（上中下）
            * place-content属性是align-content属性和justify-content属性的合并简写形式
            * items和content的区别是：items是项目中的内容在项目中的对齐方式，content是项目相对容器的对齐方式
            * 属性值
                * start：对齐容器的起始边框
                * end：对齐容器的结束边框
                * center：容器内部居中。
                * stretch：项目大小没有指定时，拉伸占据整个网格容器。
                * space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍
                * space-between：项目与项目的间隔相等，项目与容器边框之间没有间隔。
                * space-evenly：项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔
        * grid-auto-columns、grid-auto-rows
            * 有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。
            * grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。
        * grid-template
            * grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式
        * grid属性
            * grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式
    * 项目属性
        * grid-column-start、grid-column-end、grid-row-start、grid-row-end、grid-column、grid-row
            * grid-column-start属性：左边框所在的垂直网格线
            * grid-column-end属性：右边框所在的垂直网格线
            * grid-row-start属性：上边框所在的水平网格线
            * grid-row-end属性：下边框所在的水平网格线
            * 注：使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序
            * grid-column属性是grid-column-start和grid-column-end的合并简写形式
            * grid-row属性是grid-row-start属性和grid-row-end的合并简写形式
            * 注：这两个属性之中，也可以使用span关键字，表示跨越多少个网格
        * grid-area
            * grid-area属性指定项目放在哪一个区域
        * justify-self、align-self、place-self
            * justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目
            * align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目
            * place-self属性是align-self属性和justify-self属性的合并简写形式
    * 参考网址:https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html
2. transform
    * transform 属性向元素应用 2D 或 3D 转换。
    * 该属性允许我们对元素进行旋转、缩放、移动或倾斜
    * 常用值
        * translate: 位移
        * scale: 缩放
        * rotate: 旋转
    * 案例
        ```html
        <!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>测试transform变形效果</title>
        <style>
        .baseDiv{
            width: 100px;
            height: 100px;
            background-color: #dfdfdf;
        }
        .translateDiv{
            transform: translate(10px,20px);
        }
        .scaleDiv{
            transform: scale(1.5, 1);
        }
        .rotateDiv{
            transform: rotate(30deg);
        }
        </style>
        </head>
        <body>
            <span>元素（基础）</span>
            <div class="baseDiv"></div>
            <span>位移</span>
            <div class="baseDiv translateDiv"></div>
            <span>缩放</span>
            <div class="baseDiv scaleDiv"></div>
            <span>旋转</span>
            <div class="baseDiv rotateDiv"></div>
        </body>
        </html>
        ```
## 2022-08-26
1. requestAnimationFrame
    * 简介
        * requestAnimationFrame() 他的作用就是代替定时器做更加流畅高性能的动画，做可以匹配设备刷新率的动画，他解决了定时器做动画时间间隔不稳定的问题
        * 用法与setTimeout差不多，setTimeout可以通过clearTImeout()关闭定时器。那么requestAnimationFrame()使用的就是cancelAnimationFrame()关闭动画
        * requestAnimationFrame() 可以自动匹配设备帧率来展示动画（120帧就每秒执行120次）
    * 相比较setTimeout做动画的优点
        * setTimeout受事件轮询影响，可能会出现延迟，导致动画延迟卡顿
        * requestAnimationFrame的执行时间受设备的系统影响，通常每秒执行回调函数的次数是60，对应屏幕每秒的帧数60fps
    * 动画代码示例
        * setTimeout版本
            ```javascript
            const box = document.querySelector('.box')
            let move
            let timer = setTimeout(function fn(){
                move = parseInt(getComputedStyle(box).left)
                if (move < 800) {
                    box.style.left = move + 8 + 'px'
                    setTimeout(fn, 1000/60)
                } else {
                    clearTimeout(timer)
                }
            }, 1000/60)
            ```
        * requestAnimationFrame版本
            ```javascript
            const box = document.querySelector('.box')
            let move
            let timer = requestAnimationFrame(function fn(){
                move = parseInt(getComputedStyle(box).left)
                if (move < 800) {
                    box.style.left = move + 8 + 'px'
                    requestAnimationFrame(fn)
                } else {
                    cancelAnimationFrame(timer)
                }
            })
            ```
    * 浏览器兼容问题
        * requestAnimationFrame有浏览器兼容问题，我们可以参照阮一峰大神的代码解决
            ```javascript
            window.requestAnimationFrame = (function() {
                return window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    (callback) => {
                        window.setTimeout(callback, 1000 / 60)
                    }
            })()
            ```
    * 参考网址：https://blog.csdn.net/m0_46217225/article/details/117933555
2. js获取盒子模型对应的高宽
    * dom.style.width/height
        * 只使用获取内联元素的宽和高
    * dom.currentStyle.width/height
        * 获取渲染后的宽高，但是仅IE支持
    * window.getComputedStyle(dom).width/height
        * 与2原理相同，但是兼容性，通用性会更好一些
    * dom.getBoundingClientRect().width/height
        * 计算元素绝对位置，可以获取元素的位置参数
        * 参数
            * left: 元素的左边距离
            * right: 元素的右边距离
            * top: 元素的顶部距离
            * bottom: 元素的底部距离
            * width: 元素的宽度
            * height: 元素的高度
## 2022-08-29
1. 页面可见性接口(Page Visibility API)
    * 介绍
        * 开发者监听用户离开页面，通常的方法是
            * pagehide
            * beforeunload
            * unload
        * 但是，这些方法在手机上可能都不会被触发，页面就直接关闭了。页面被系统切换，或者系统清除浏览器进程，使用以前的三种方法，是无法监听的。
        * 针对以上问题，出现了Page Visibility API，不管是手机还是桌面电脑，这个API都可以监听到页面可见性的变化
    * 相关属性和方法
        * document.visibilityState
            * 属性值
                * hidden：页面彻底不可见
                * visible：页面至少一部分可见
                * prerender：页面即将或正在渲染，处于不可见状态（可能部分浏览器不支持）
            * 返回hidden的情况
                * 浏览器最小化
                * 浏览器没有最小化，但是当前页面切换成了背景页
                * 浏览器将要卸载（unload）页面
                * 操作系统触发锁屏屏幕
            * 注意：document.visibilityState属性只针对顶层窗口，内嵌的```<iframe>```页面的document.visibilityState属性由顶层窗口决定。使用 CSS 属性隐藏```<iframe>```页面（比如display: none;），并不会影响内嵌页面的可见性
        * document.hidden
            * 由于历史原因，Page Visibility API还定义了document.hidden属性，该属性是一个boolean值，表示当前页面是否可见
            * 建议使用document.visibilityState
        * visibilitychange事件
            * 只要document.visibilityState属性发生变化，就会触发visibilitychange事件。
            * 因此，可以通过监听这个事件，跟踪页面可见性的变化
                * ```document.addEventListener('visibilitychange', () => {})```
                * ```document.onvisibilitychange = () => {}```
    * 页面卸载情况
        * 常见情况
            * 页面可见时，用户关闭Tab页或浏览器窗口
            * 页面可见时，用户在当前窗口前往另一个页面
            * 页面不可见时，用户或系统关闭浏览器窗口
        * 这三种情况都会触发visibilitychange事件，前两种情况，该事件在用户离开页面时触发；最后一种情况，该事件在页面从可见状态变成不可见状态时触发
        * visibilitychange事件比pagehide,beforeunload,unload事件更可靠
            * unload事件在任何情况下都不必监听，beforeunload事件只适用于一种场景：用户修改表单，没有提交就离开当前页面
            * unload事件和beforeunload事件如果被指定，浏览器不会缓存当前页面
    * 代码实例
        ```javascript
        window.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                // 页面不可见了
            } else if (document.visibilityState === 'visible') {
                // 页面可见了
            }
        })
        ```
    * 参考网址：https://www.bookstack.cn/read/webapi-tutorial/docs-page-visibility.md
## 2022-09-01
1. css动画-animation
    * 介绍
        * CSS动画，也称关键帧动画，通过@keyframes来定义关键帧，在CSS中，开发者不需要给出每一帧的定义，只要定义一些关键帧即可，其余的帧，浏览器会根据计时函数插值计算出来
        * 实现方法
            * 首先需要使用@keyframes来定义关键帧
            * 之后使用animation来规定动画的相关设置
    * 相关属性和方法
        * @keyframes
            * @keyframes定义了一个动画，并定义具体的动画效果
            * @keyframes定义的动画并不是直接执行，需要借助animation来运转
            * @keyframes用百分比来规定改变发生的时间，或者使用from和to，等价于0%和100%
                * 注意：百分比是指动画完成一遍的时间长度的百分比，0%是动画的开始时间，50%是动画完成一半的时间，100%是动画的结束时间
            * 写法
                ```css
                @keyframes animationname {
                    keyframes-selector {css-styles}
                }
                ```
            * 属性详解
                * animationname：必需。定义动画的名称
                * keyframes-selector：必需。定义动画的过程，合法的值如下：
                    * 0-100%
                    * from 
                    * to
                * css-styles：必需。一个或多个合法的css样式属性
        * animation
            * animation是一个简写属性，包括以下的属性
                * animation-name：指定@keyframes动画的名称
                * animation-duration：指定完成一个周期需要的时间，单位s或ms，默认0
                * animation-timing-function：指定动画如何完成一个周期，默认“ease”
                    * 速度曲线：
                        * linear：平均速度，从头到尾速度一样
                        * ease：动画从慢开始，逐渐变快，最后在结束前变慢
                        * ease-in：动画从慢开始，逐渐变快
                        * ease-out：动画从快开始，逐渐变慢
                        * ease-in-out：动画从慢开始，中间快，再从慢结束
                        * cubic-bezier(n,n,n)：自定义贝塞尔曲线，也就是自定义速度
                    * 帧：
                        * steps(number,start/end)：number代表把这个动画分为多少帧，start的意思是动画以一帧开始，也就是直接从0%开始，而end的意思是以0帧开始，也就是从初态开始，再进入第一帧（0%）。【就是start要比end快一帧】
                        * 注意：
                            * 速度曲线是动画是连续的，是一直动的，而分为step后，这个动画就是拆分为多少帧，那么这个动画就是不是连续的了，而是一步一步、一帧一帧的（就像翻书一样，一下翻一页）
                            * start会丢失第一帧，end会丢失最后一帧，什么意思呢？就是start会丢失0%这一帧，直接开始下一帧；而end会丢失100%这一帧，在之前一帧就结束。
                * animation-delay：指定动画延时时间，即动画什么时候开始。默认0
                * animation-iteration-count：指定动画播放的次数，默认1
                    * 数字：播放的次数
                    * infinite：无限播放
                * animation-direction：指定动画播放的方向，默认normal
                    * normal：从 0% 到 100%
                    * reverse：从 100% 到 0%
                    * alternate: 从 0% 到 100% 到 0%
                    * alternate-reverse：从 100% 到 0% 到 100%
                    * 注：如果动画设置为只播放一次，alternate和alternate-reverse将没有效果
                * animation-fill-mode：指定动画填充模式，默认none
                    * none：默认值，动画在动画执行之前和之后不会应用任何样式到目标元素。
                    * forwards：动画完成后，元素状态保持为最后一帧的状态。
                    * backwards：有动画延迟时，动画开始前，元素状态保持为第一帧的状态。
                    * both:动画遵循 forwards 和 backwards 的规则。也就是说，上述二者效果都有。
                * animation-play-state：指定动画播放状态，正在运行或暂停，默认running
                    * paused：暂停动画
                    * running：运行动画
            * 注：最好按照如下顺序书写
                ```css
                animation: name duration timing-function delay iteration-count direction fill-mode play-state;
                ```
    * 代码实例
        ```html
        <!DOCTYPE html>
        <html lang="en">
        <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>测试一下animation动画</title>
        </head>
        <style>
        @keyframes myAnimation1 {
            from {
            width: 100px;
            height: 100px;
            background-color: red;
            }
            to {
            width: 400px;
            height: 400px;
            background-color: yellow;
            }
        }
        .mainDiv1{
            animation: myAnimation1 5s infinite linear;
        }
        </style>
        <body>
        <div class="mainDiv1"></div>
        </body>
        </html>
        ```
    * 参考网址：
        * https://blog.csdn.net/qq_44845659/article/details/122908173
        * https://juejin.cn/post/7133924375568318500
        * https://blog.csdn.net/qq_40028324/article/details/102675838
## 2022-09-07
1. 页面生命周期
    * 简介
        * W3C 新制定了一个页面生命周期（Page Lifecycle）API，统一了网页从诞生到卸载的行为模式，并且定义了新的事件，允许开发者响应网页状态的各种转换
        * Chrome 68 支持这个 API，对于老式浏览器可以使用谷歌开发的兼容库 PageLifecycle.js
    * 阶段：
        <image src="../../study-images/md-images/页面生命周期.png"/>
        * Active阶段
            * 页面处于可见状态，且拥有拥有焦点
        * Passive阶段
            * 网页可见，但没有输入焦点，无法接受输入，UI更新（比如动画）仍然在执行
            * 实例
                * 桌面同时有多个窗口的情况
        * Hidden阶段
            * 网页不可见，但尚未冻结，UI更新不执行
            * 实例
                * 桌面被其他窗口占据
        * Terminated阶段
            * 网页卸载，任何新任务都不会在这个阶段启动，并且如果运行时间太长，正在进行的任务可能会被终止
            * 注意：这个阶段总是在Hidden阶段之后发生，也就是说，用户主动离开当前页面，总是先进入Hidden阶段，再进入Terminated阶段
            * 实例
                * 用户主动关闭窗口
                * 在同一个窗口前往其他页面
        * Frozen阶段
            * 网页不会再被分配CPU计算资源；定时器、回调函数、网络请求、DOM操作都不会执行，不过正在运行的任务会执行完。
            * 浏览器可能会允许Frozen阶段的页面，周期性复苏一小段时间，短暂变回Hidden状态，允许一小部分任务执行
            * 实例
                * 网页处于Hidden阶段时间过久，用户又不关闭网页，浏览器就有可能冻结网页，使其进入Frozen阶段
                * 处于可见状态的页面长时间没有操作，也会进入Frozen阶段
        * Discarded阶段
            * 该阶段浏览器自动卸载网页，清除该网页的内存占用
            * 任何类型的新任务或者Javascript代码，都不能在此阶段执行，因为这时通常处于资源限制的情况下
            * 网页被浏览器自动 Discarded 以后，它的 Tab 窗口还是在的。如果用户重新访问这个 Tab 页，浏览器将会重新向服务器发出请求，再一次重新加载网页，回到 Active 阶段
            * 实例
                * 网页长时间处于Frozen阶段，用户又不唤醒页面
                * Passive阶段的网页如果长时间没有互动，也可能直接进入Discarded阶段
    * 常用场景分析
        * 用户打开网页后，又切换到其他 App，但只过了一会又回到网页
            * 网页由Active变成Hidden，又变回Active
        * 用户打开网页后，又切换到其他 App，并且长时候使用后者，导致系统自动丢弃网页
            * 网页由Active变成Hidden，再变成Frozen，最后Discarded
        * 用户打开网页后，又切换到其他 App，然后从任务管理器里面将浏览器进程清除
            * 网页由Active变成Hidden，然后Terminated
        * 系统丢弃了某个 Tab 里面的页面后，用户重新打开这个 Tab
            * 网页由Discarded变成Active
    * 相关事件与Api
        * 与生命周期相关的事件
            * focus事件
            * blur事件
            * visibilitychange事件
            * freeze事件（新定义）：事件在网页进入 Frozen 阶段时触发
            * resume事件（新定义）：事件在网页离开 Frozen 阶段，变为 Active / Passive / Hidden 阶段时触发
            * pageshow事件
            * pagehide事件
            * beforeunload事件
            * unload事件
        * 获取当前阶段
            * 如果网页处于Active、Passive或Hidden阶段，可以通过下面的代码，获取网页当前的状态
                ```javascript
                const getState = () => {
                    if(document.visibilityState === 'hidden') {
                        return 'hidden'
                    }
                    if(document.hasFocus()) {
                        return 'active'
                    }
                    return 'passive'
                }
                ```
            * 如果网页处于Frozen和Terminated状态，由于定时器代码不会执行，只能通过事件监听判断状态。
                * 进入Frozen阶段，可以监听freeze事件
                * 进入Terminated阶段，可以监听pagehide事件
        * document.wasDiscarded
            * 如果某个选项卡处于 Frozen 阶段，就随时有可能被系统丢弃，进入 Discarded 阶段。如果后来用户再次点击该选项卡，浏览器会重新加载该页面。
            * 可以通过document.wasDiscarded属性，了解先前的网页是否被丢弃了
                ```javascript
                if(document.wasDiscarded) {
                    // 该网页已经不是原来的状态了，曾经被浏览器丢弃过
                    // 恢复以前的状态
                    getPersistedState(self.discardedClientId)
                }
                ```
            * 同时，window对象上会新增window.clientId和window.discardedClientId两个属性，用来恢复丢弃前的状态
    * 参考网址：https://www.bookstack.cn/read/webapi-tutorial/docs-page-lifecycle.md
## 2022-09-08
1. 










## 待学习目录
* 排序
* service worker
* H5中新增的内容
* 订阅与发布
* SVG
* Canvas
* websocket
* IndexedDB:https://blog.csdn.net/congboer/article/details/117405572





* 大技术
    * vue全家桶(vue,vuex,vue-router,vuecli,pinia,vite)
    * typeScript
    * react
    * sass, less
    * nodejs
    * webpack
    * express,koa
    * nuxt
    * nginx



## https://www.cnblogs.com/wjian0916/articles/15109038.html
## https://objtube.gitee.io/front-end-roadmap/#/
## 前端八股文https://juejin.cn/post/7016593221815910408






